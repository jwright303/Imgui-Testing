// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCANHEADSPECIFICATION_JOESCAN_SCHEMA_CLIENT_H_
#define FLATBUFFERS_GENERATED_SCANHEADSPECIFICATION_JOESCAN_SCHEMA_CLIENT_H_

#include "flatbuffers/flatbuffers.h"

#include "ScanHeadType_generated.h"

namespace joescan {
namespace schema {
namespace client {

struct ConfigurationGroup;

struct ScanHeadSpecification;
struct ScanHeadSpecificationBuilder;
struct ScanHeadSpecificationT;

enum ConfigurationGroupPrimary : uint8_t {
  ConfigurationGroupPrimary_INVALID = 0,
  ConfigurationGroupPrimary_CAMERA = 1,
  ConfigurationGroupPrimary_LASER = 2,
  ConfigurationGroupPrimary_MIN = ConfigurationGroupPrimary_INVALID,
  ConfigurationGroupPrimary_MAX = ConfigurationGroupPrimary_LASER
};

inline const ConfigurationGroupPrimary (&EnumValuesConfigurationGroupPrimary())[3] {
  static const ConfigurationGroupPrimary values[] = {
    ConfigurationGroupPrimary_INVALID,
    ConfigurationGroupPrimary_CAMERA,
    ConfigurationGroupPrimary_LASER
  };
  return values;
}

inline const char * const *EnumNamesConfigurationGroupPrimary() {
  static const char * const names[4] = {
    "INVALID",
    "CAMERA",
    "LASER",
    nullptr
  };
  return names;
}

inline const char *EnumNameConfigurationGroupPrimary(ConfigurationGroupPrimary e) {
  if (flatbuffers::IsOutRange(e, ConfigurationGroupPrimary_INVALID, ConfigurationGroupPrimary_LASER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConfigurationGroupPrimary()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ConfigurationGroup FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t camera_port_;
  uint32_t laser_port_;

 public:
  ConfigurationGroup()
      : camera_port_(0),
        laser_port_(0) {
  }
  ConfigurationGroup(uint32_t _camera_port, uint32_t _laser_port)
      : camera_port_(flatbuffers::EndianScalar(_camera_port)),
        laser_port_(flatbuffers::EndianScalar(_laser_port)) {
  }
  uint32_t camera_port() const {
    return flatbuffers::EndianScalar(camera_port_);
  }
  uint32_t laser_port() const {
    return flatbuffers::EndianScalar(laser_port_);
  }
};
FLATBUFFERS_STRUCT_END(ConfigurationGroup, 8);

struct ScanHeadSpecificationT : public flatbuffers::NativeTable {
  typedef ScanHeadSpecification TableType;
  std::string product_str{};
  uint32_t number_of_cameras = 0;
  uint32_t number_of_lasers = 0;
  uint32_t max_scan_period_us = 0;
  uint32_t min_scan_period_us = 0;
  uint32_t max_camera_columns = 0;
  uint32_t max_camera_rows = 0;
  uint32_t max_laser_on_time_us = 0;
  uint32_t min_laser_on_time_us = 0;
  uint32_t max_camera_exposure_us = 0;
  uint32_t min_camera_exposure_us = 0;
  std::vector<uint32_t> camera_port_to_id{};
  std::vector<uint32_t> laser_port_to_id{};
  std::vector<joescan::schema::client::ConfigurationGroup> configuration_groups{};
  joescan::schema::client::ConfigurationGroupPrimary configuration_group_primary = joescan::schema::client::ConfigurationGroupPrimary_INVALID;
  uint32_t max_configuration_groups = 0;
  uint32_t camera_port_cable_upstream = 0;
};

struct ScanHeadSpecification FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScanHeadSpecificationT NativeTableType;
  typedef ScanHeadSpecificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRODUCT_STR = 4,
    VT_NUMBER_OF_CAMERAS = 6,
    VT_NUMBER_OF_LASERS = 8,
    VT_MAX_SCAN_PERIOD_US = 10,
    VT_MIN_SCAN_PERIOD_US = 12,
    VT_MAX_CAMERA_COLUMNS = 14,
    VT_MAX_CAMERA_ROWS = 16,
    VT_MAX_LASER_ON_TIME_US = 18,
    VT_MIN_LASER_ON_TIME_US = 20,
    VT_MAX_CAMERA_EXPOSURE_US = 22,
    VT_MIN_CAMERA_EXPOSURE_US = 24,
    VT_CAMERA_PORT_TO_ID = 26,
    VT_LASER_PORT_TO_ID = 28,
    VT_CONFIGURATION_GROUPS = 30,
    VT_CONFIGURATION_GROUP_PRIMARY = 32,
    VT_MAX_CONFIGURATION_GROUPS = 34,
    VT_CAMERA_PORT_CABLE_UPSTREAM = 36
  };
  const flatbuffers::String *product_str() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCT_STR);
  }
  uint32_t number_of_cameras() const {
    return GetField<uint32_t>(VT_NUMBER_OF_CAMERAS, 0);
  }
  uint32_t number_of_lasers() const {
    return GetField<uint32_t>(VT_NUMBER_OF_LASERS, 0);
  }
  uint32_t max_scan_period_us() const {
    return GetField<uint32_t>(VT_MAX_SCAN_PERIOD_US, 0);
  }
  uint32_t min_scan_period_us() const {
    return GetField<uint32_t>(VT_MIN_SCAN_PERIOD_US, 0);
  }
  uint32_t max_camera_columns() const {
    return GetField<uint32_t>(VT_MAX_CAMERA_COLUMNS, 0);
  }
  uint32_t max_camera_rows() const {
    return GetField<uint32_t>(VT_MAX_CAMERA_ROWS, 0);
  }
  uint32_t max_laser_on_time_us() const {
    return GetField<uint32_t>(VT_MAX_LASER_ON_TIME_US, 0);
  }
  uint32_t min_laser_on_time_us() const {
    return GetField<uint32_t>(VT_MIN_LASER_ON_TIME_US, 0);
  }
  uint32_t max_camera_exposure_us() const {
    return GetField<uint32_t>(VT_MAX_CAMERA_EXPOSURE_US, 0);
  }
  uint32_t min_camera_exposure_us() const {
    return GetField<uint32_t>(VT_MIN_CAMERA_EXPOSURE_US, 0);
  }
  const flatbuffers::Vector<uint32_t> *camera_port_to_id() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_CAMERA_PORT_TO_ID);
  }
  const flatbuffers::Vector<uint32_t> *laser_port_to_id() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_LASER_PORT_TO_ID);
  }
  const flatbuffers::Vector<const joescan::schema::client::ConfigurationGroup *> *configuration_groups() const {
    return GetPointer<const flatbuffers::Vector<const joescan::schema::client::ConfigurationGroup *> *>(VT_CONFIGURATION_GROUPS);
  }
  joescan::schema::client::ConfigurationGroupPrimary configuration_group_primary() const {
    return static_cast<joescan::schema::client::ConfigurationGroupPrimary>(GetField<uint8_t>(VT_CONFIGURATION_GROUP_PRIMARY, 0));
  }
  uint32_t max_configuration_groups() const {
    return GetField<uint32_t>(VT_MAX_CONFIGURATION_GROUPS, 0);
  }
  uint32_t camera_port_cable_upstream() const {
    return GetField<uint32_t>(VT_CAMERA_PORT_CABLE_UPSTREAM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PRODUCT_STR) &&
           verifier.VerifyString(product_str()) &&
           VerifyField<uint32_t>(verifier, VT_NUMBER_OF_CAMERAS) &&
           VerifyField<uint32_t>(verifier, VT_NUMBER_OF_LASERS) &&
           VerifyField<uint32_t>(verifier, VT_MAX_SCAN_PERIOD_US) &&
           VerifyField<uint32_t>(verifier, VT_MIN_SCAN_PERIOD_US) &&
           VerifyField<uint32_t>(verifier, VT_MAX_CAMERA_COLUMNS) &&
           VerifyField<uint32_t>(verifier, VT_MAX_CAMERA_ROWS) &&
           VerifyField<uint32_t>(verifier, VT_MAX_LASER_ON_TIME_US) &&
           VerifyField<uint32_t>(verifier, VT_MIN_LASER_ON_TIME_US) &&
           VerifyField<uint32_t>(verifier, VT_MAX_CAMERA_EXPOSURE_US) &&
           VerifyField<uint32_t>(verifier, VT_MIN_CAMERA_EXPOSURE_US) &&
           VerifyOffset(verifier, VT_CAMERA_PORT_TO_ID) &&
           verifier.VerifyVector(camera_port_to_id()) &&
           VerifyOffset(verifier, VT_LASER_PORT_TO_ID) &&
           verifier.VerifyVector(laser_port_to_id()) &&
           VerifyOffset(verifier, VT_CONFIGURATION_GROUPS) &&
           verifier.VerifyVector(configuration_groups()) &&
           VerifyField<uint8_t>(verifier, VT_CONFIGURATION_GROUP_PRIMARY) &&
           VerifyField<uint32_t>(verifier, VT_MAX_CONFIGURATION_GROUPS) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT_CABLE_UPSTREAM) &&
           verifier.EndTable();
  }
  ScanHeadSpecificationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScanHeadSpecificationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScanHeadSpecification> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScanHeadSpecificationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScanHeadSpecificationBuilder {
  typedef ScanHeadSpecification Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_product_str(flatbuffers::Offset<flatbuffers::String> product_str) {
    fbb_.AddOffset(ScanHeadSpecification::VT_PRODUCT_STR, product_str);
  }
  void add_number_of_cameras(uint32_t number_of_cameras) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_NUMBER_OF_CAMERAS, number_of_cameras, 0);
  }
  void add_number_of_lasers(uint32_t number_of_lasers) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_NUMBER_OF_LASERS, number_of_lasers, 0);
  }
  void add_max_scan_period_us(uint32_t max_scan_period_us) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_MAX_SCAN_PERIOD_US, max_scan_period_us, 0);
  }
  void add_min_scan_period_us(uint32_t min_scan_period_us) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_MIN_SCAN_PERIOD_US, min_scan_period_us, 0);
  }
  void add_max_camera_columns(uint32_t max_camera_columns) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_MAX_CAMERA_COLUMNS, max_camera_columns, 0);
  }
  void add_max_camera_rows(uint32_t max_camera_rows) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_MAX_CAMERA_ROWS, max_camera_rows, 0);
  }
  void add_max_laser_on_time_us(uint32_t max_laser_on_time_us) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_MAX_LASER_ON_TIME_US, max_laser_on_time_us, 0);
  }
  void add_min_laser_on_time_us(uint32_t min_laser_on_time_us) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_MIN_LASER_ON_TIME_US, min_laser_on_time_us, 0);
  }
  void add_max_camera_exposure_us(uint32_t max_camera_exposure_us) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_MAX_CAMERA_EXPOSURE_US, max_camera_exposure_us, 0);
  }
  void add_min_camera_exposure_us(uint32_t min_camera_exposure_us) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_MIN_CAMERA_EXPOSURE_US, min_camera_exposure_us, 0);
  }
  void add_camera_port_to_id(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> camera_port_to_id) {
    fbb_.AddOffset(ScanHeadSpecification::VT_CAMERA_PORT_TO_ID, camera_port_to_id);
  }
  void add_laser_port_to_id(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> laser_port_to_id) {
    fbb_.AddOffset(ScanHeadSpecification::VT_LASER_PORT_TO_ID, laser_port_to_id);
  }
  void add_configuration_groups(flatbuffers::Offset<flatbuffers::Vector<const joescan::schema::client::ConfigurationGroup *>> configuration_groups) {
    fbb_.AddOffset(ScanHeadSpecification::VT_CONFIGURATION_GROUPS, configuration_groups);
  }
  void add_configuration_group_primary(joescan::schema::client::ConfigurationGroupPrimary configuration_group_primary) {
    fbb_.AddElement<uint8_t>(ScanHeadSpecification::VT_CONFIGURATION_GROUP_PRIMARY, static_cast<uint8_t>(configuration_group_primary), 0);
  }
  void add_max_configuration_groups(uint32_t max_configuration_groups) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_MAX_CONFIGURATION_GROUPS, max_configuration_groups, 0);
  }
  void add_camera_port_cable_upstream(uint32_t camera_port_cable_upstream) {
    fbb_.AddElement<uint32_t>(ScanHeadSpecification::VT_CAMERA_PORT_CABLE_UPSTREAM, camera_port_cable_upstream, 0);
  }
  explicit ScanHeadSpecificationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScanHeadSpecification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScanHeadSpecification>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScanHeadSpecification> CreateScanHeadSpecification(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> product_str = 0,
    uint32_t number_of_cameras = 0,
    uint32_t number_of_lasers = 0,
    uint32_t max_scan_period_us = 0,
    uint32_t min_scan_period_us = 0,
    uint32_t max_camera_columns = 0,
    uint32_t max_camera_rows = 0,
    uint32_t max_laser_on_time_us = 0,
    uint32_t min_laser_on_time_us = 0,
    uint32_t max_camera_exposure_us = 0,
    uint32_t min_camera_exposure_us = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> camera_port_to_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> laser_port_to_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<const joescan::schema::client::ConfigurationGroup *>> configuration_groups = 0,
    joescan::schema::client::ConfigurationGroupPrimary configuration_group_primary = joescan::schema::client::ConfigurationGroupPrimary_INVALID,
    uint32_t max_configuration_groups = 0,
    uint32_t camera_port_cable_upstream = 0) {
  ScanHeadSpecificationBuilder builder_(_fbb);
  builder_.add_camera_port_cable_upstream(camera_port_cable_upstream);
  builder_.add_max_configuration_groups(max_configuration_groups);
  builder_.add_configuration_groups(configuration_groups);
  builder_.add_laser_port_to_id(laser_port_to_id);
  builder_.add_camera_port_to_id(camera_port_to_id);
  builder_.add_min_camera_exposure_us(min_camera_exposure_us);
  builder_.add_max_camera_exposure_us(max_camera_exposure_us);
  builder_.add_min_laser_on_time_us(min_laser_on_time_us);
  builder_.add_max_laser_on_time_us(max_laser_on_time_us);
  builder_.add_max_camera_rows(max_camera_rows);
  builder_.add_max_camera_columns(max_camera_columns);
  builder_.add_min_scan_period_us(min_scan_period_us);
  builder_.add_max_scan_period_us(max_scan_period_us);
  builder_.add_number_of_lasers(number_of_lasers);
  builder_.add_number_of_cameras(number_of_cameras);
  builder_.add_product_str(product_str);
  builder_.add_configuration_group_primary(configuration_group_primary);
  return builder_.Finish();
}

inline flatbuffers::Offset<ScanHeadSpecification> CreateScanHeadSpecificationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *product_str = nullptr,
    uint32_t number_of_cameras = 0,
    uint32_t number_of_lasers = 0,
    uint32_t max_scan_period_us = 0,
    uint32_t min_scan_period_us = 0,
    uint32_t max_camera_columns = 0,
    uint32_t max_camera_rows = 0,
    uint32_t max_laser_on_time_us = 0,
    uint32_t min_laser_on_time_us = 0,
    uint32_t max_camera_exposure_us = 0,
    uint32_t min_camera_exposure_us = 0,
    const std::vector<uint32_t> *camera_port_to_id = nullptr,
    const std::vector<uint32_t> *laser_port_to_id = nullptr,
    const std::vector<joescan::schema::client::ConfigurationGroup> *configuration_groups = nullptr,
    joescan::schema::client::ConfigurationGroupPrimary configuration_group_primary = joescan::schema::client::ConfigurationGroupPrimary_INVALID,
    uint32_t max_configuration_groups = 0,
    uint32_t camera_port_cable_upstream = 0) {
  auto product_str__ = product_str ? _fbb.CreateString(product_str) : 0;
  auto camera_port_to_id__ = camera_port_to_id ? _fbb.CreateVector<uint32_t>(*camera_port_to_id) : 0;
  auto laser_port_to_id__ = laser_port_to_id ? _fbb.CreateVector<uint32_t>(*laser_port_to_id) : 0;
  auto configuration_groups__ = configuration_groups ? _fbb.CreateVectorOfStructs<joescan::schema::client::ConfigurationGroup>(*configuration_groups) : 0;
  return joescan::schema::client::CreateScanHeadSpecification(
      _fbb,
      product_str__,
      number_of_cameras,
      number_of_lasers,
      max_scan_period_us,
      min_scan_period_us,
      max_camera_columns,
      max_camera_rows,
      max_laser_on_time_us,
      min_laser_on_time_us,
      max_camera_exposure_us,
      min_camera_exposure_us,
      camera_port_to_id__,
      laser_port_to_id__,
      configuration_groups__,
      configuration_group_primary,
      max_configuration_groups,
      camera_port_cable_upstream);
}

flatbuffers::Offset<ScanHeadSpecification> CreateScanHeadSpecification(flatbuffers::FlatBufferBuilder &_fbb, const ScanHeadSpecificationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ScanHeadSpecificationT *ScanHeadSpecification::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScanHeadSpecificationT>(new ScanHeadSpecificationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScanHeadSpecification::UnPackTo(ScanHeadSpecificationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = product_str(); if (_e) _o->product_str = _e->str(); }
  { auto _e = number_of_cameras(); _o->number_of_cameras = _e; }
  { auto _e = number_of_lasers(); _o->number_of_lasers = _e; }
  { auto _e = max_scan_period_us(); _o->max_scan_period_us = _e; }
  { auto _e = min_scan_period_us(); _o->min_scan_period_us = _e; }
  { auto _e = max_camera_columns(); _o->max_camera_columns = _e; }
  { auto _e = max_camera_rows(); _o->max_camera_rows = _e; }
  { auto _e = max_laser_on_time_us(); _o->max_laser_on_time_us = _e; }
  { auto _e = min_laser_on_time_us(); _o->min_laser_on_time_us = _e; }
  { auto _e = max_camera_exposure_us(); _o->max_camera_exposure_us = _e; }
  { auto _e = min_camera_exposure_us(); _o->min_camera_exposure_us = _e; }
  { auto _e = camera_port_to_id(); if (_e) { _o->camera_port_to_id.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->camera_port_to_id[_i] = _e->Get(_i); } } }
  { auto _e = laser_port_to_id(); if (_e) { _o->laser_port_to_id.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->laser_port_to_id[_i] = _e->Get(_i); } } }
  { auto _e = configuration_groups(); if (_e) { _o->configuration_groups.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->configuration_groups[_i] = *_e->Get(_i); } } }
  { auto _e = configuration_group_primary(); _o->configuration_group_primary = _e; }
  { auto _e = max_configuration_groups(); _o->max_configuration_groups = _e; }
  { auto _e = camera_port_cable_upstream(); _o->camera_port_cable_upstream = _e; }
}

inline flatbuffers::Offset<ScanHeadSpecification> ScanHeadSpecification::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScanHeadSpecificationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScanHeadSpecification(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScanHeadSpecification> CreateScanHeadSpecification(flatbuffers::FlatBufferBuilder &_fbb, const ScanHeadSpecificationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScanHeadSpecificationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _product_str = _o->product_str.empty() ? 0 : _fbb.CreateString(_o->product_str);
  auto _number_of_cameras = _o->number_of_cameras;
  auto _number_of_lasers = _o->number_of_lasers;
  auto _max_scan_period_us = _o->max_scan_period_us;
  auto _min_scan_period_us = _o->min_scan_period_us;
  auto _max_camera_columns = _o->max_camera_columns;
  auto _max_camera_rows = _o->max_camera_rows;
  auto _max_laser_on_time_us = _o->max_laser_on_time_us;
  auto _min_laser_on_time_us = _o->min_laser_on_time_us;
  auto _max_camera_exposure_us = _o->max_camera_exposure_us;
  auto _min_camera_exposure_us = _o->min_camera_exposure_us;
  auto _camera_port_to_id = _o->camera_port_to_id.size() ? _fbb.CreateVector(_o->camera_port_to_id) : 0;
  auto _laser_port_to_id = _o->laser_port_to_id.size() ? _fbb.CreateVector(_o->laser_port_to_id) : 0;
  auto _configuration_groups = _o->configuration_groups.size() ? _fbb.CreateVectorOfStructs(_o->configuration_groups) : 0;
  auto _configuration_group_primary = _o->configuration_group_primary;
  auto _max_configuration_groups = _o->max_configuration_groups;
  auto _camera_port_cable_upstream = _o->camera_port_cable_upstream;
  return joescan::schema::client::CreateScanHeadSpecification(
      _fbb,
      _product_str,
      _number_of_cameras,
      _number_of_lasers,
      _max_scan_period_us,
      _min_scan_period_us,
      _max_camera_columns,
      _max_camera_rows,
      _max_laser_on_time_us,
      _min_laser_on_time_us,
      _max_camera_exposure_us,
      _min_camera_exposure_us,
      _camera_port_to_id,
      _laser_port_to_id,
      _configuration_groups,
      _configuration_group_primary,
      _max_configuration_groups,
      _camera_port_cable_upstream);
}

inline const joescan::schema::client::ScanHeadSpecification *GetScanHeadSpecification(const void *buf) {
  return flatbuffers::GetRoot<joescan::schema::client::ScanHeadSpecification>(buf);
}

inline const joescan::schema::client::ScanHeadSpecification *GetSizePrefixedScanHeadSpecification(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<joescan::schema::client::ScanHeadSpecification>(buf);
}

inline bool VerifyScanHeadSpecificationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<joescan::schema::client::ScanHeadSpecification>(nullptr);
}

inline bool VerifySizePrefixedScanHeadSpecificationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<joescan::schema::client::ScanHeadSpecification>(nullptr);
}

inline void FinishScanHeadSpecificationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<joescan::schema::client::ScanHeadSpecification> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedScanHeadSpecificationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<joescan::schema::client::ScanHeadSpecification> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<joescan::schema::client::ScanHeadSpecificationT> UnPackScanHeadSpecification(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<joescan::schema::client::ScanHeadSpecificationT>(GetScanHeadSpecification(buf)->UnPack(res));
}

inline std::unique_ptr<joescan::schema::client::ScanHeadSpecificationT> UnPackSizePrefixedScanHeadSpecification(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<joescan::schema::client::ScanHeadSpecificationT>(GetSizePrefixedScanHeadSpecification(buf)->UnPack(res));
}

}  // namespace client
}  // namespace schema
}  // namespace joescan

#endif  // FLATBUFFERS_GENERATED_SCANHEADSPECIFICATION_JOESCAN_SCHEMA_CLIENT_H_
