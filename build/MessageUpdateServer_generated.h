// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGEUPDATESERVER_JOESCAN_SCHEMA_UPDATE_SERVER_H_
#define FLATBUFFERS_GENERATED_MESSAGEUPDATESERVER_JOESCAN_SCHEMA_UPDATE_SERVER_H_

#include "flatbuffers/flatbuffers.h"

#include "ScanHeadType_generated.h"

namespace joescan {
namespace schema {
namespace update {
namespace server {

struct InfoData;
struct InfoDataBuilder;
struct InfoDataT;

struct StatusData;
struct StatusDataBuilder;
struct StatusDataT;

struct MessageServer;
struct MessageServerBuilder;
struct MessageServerT;

enum MessageType : uint16_t {
  MessageType_NONE = 0,
  MessageType_INFO = 1,
  MessageType_STATUS = 2,
  MessageType_MIN = MessageType_NONE,
  MessageType_MAX = MessageType_STATUS
};

inline const MessageType (&EnumValuesMessageType())[3] {
  static const MessageType values[] = {
    MessageType_NONE,
    MessageType_INFO,
    MessageType_STATUS
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[4] = {
    "NONE",
    "INFO",
    "STATUS",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (flatbuffers::IsOutRange(e, MessageType_NONE, MessageType_STATUS)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

enum Status : uint16_t {
  Status_SUCCESS = 0,
  Status_ERROR_INTERNAL = 1,
  Status_ERROR_INVALID_MESSAGE = 2,
  Status_ERROR_MD5 = 3,
  Status_ERROR_EXTRACTION = 4,
  Status_ERROR_SCRIPT = 5,
  Status_ERROR_EXCEEDS_MEMORY = 6,
  Status_MIN = Status_SUCCESS,
  Status_MAX = Status_ERROR_EXCEEDS_MEMORY
};

inline const Status (&EnumValuesStatus())[7] {
  static const Status values[] = {
    Status_SUCCESS,
    Status_ERROR_INTERNAL,
    Status_ERROR_INVALID_MESSAGE,
    Status_ERROR_MD5,
    Status_ERROR_EXTRACTION,
    Status_ERROR_SCRIPT,
    Status_ERROR_EXCEEDS_MEMORY
  };
  return values;
}

inline const char * const *EnumNamesStatus() {
  static const char * const names[8] = {
    "SUCCESS",
    "ERROR_INTERNAL",
    "ERROR_INVALID_MESSAGE",
    "ERROR_MD5",
    "ERROR_EXTRACTION",
    "ERROR_SCRIPT",
    "ERROR_EXCEEDS_MEMORY",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus(Status e) {
  if (flatbuffers::IsOutRange(e, Status_SUCCESS, Status_ERROR_EXCEEDS_MEMORY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus()[index];
}

enum MessageData : uint8_t {
  MessageData_NONE = 0,
  MessageData_InfoData = 1,
  MessageData_StatusData = 2,
  MessageData_MIN = MessageData_NONE,
  MessageData_MAX = MessageData_StatusData
};

inline const MessageData (&EnumValuesMessageData())[3] {
  static const MessageData values[] = {
    MessageData_NONE,
    MessageData_InfoData,
    MessageData_StatusData
  };
  return values;
}

inline const char * const *EnumNamesMessageData() {
  static const char * const names[4] = {
    "NONE",
    "InfoData",
    "StatusData",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageData(MessageData e) {
  if (flatbuffers::IsOutRange(e, MessageData_NONE, MessageData_StatusData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageData()[index];
}

template<typename T> struct MessageDataTraits {
  static const MessageData enum_value = MessageData_NONE;
};

template<> struct MessageDataTraits<joescan::schema::update::server::InfoData> {
  static const MessageData enum_value = MessageData_InfoData;
};

template<> struct MessageDataTraits<joescan::schema::update::server::StatusData> {
  static const MessageData enum_value = MessageData_StatusData;
};

struct MessageDataUnion {
  MessageData type;
  void *value;

  MessageDataUnion() : type(MessageData_NONE), value(nullptr) {}
  MessageDataUnion(MessageDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MessageData_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageDataUnion(const MessageDataUnion &);
  MessageDataUnion &operator=(const MessageDataUnion &u)
    { MessageDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageDataUnion &operator=(MessageDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageDataUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = MessageDataTraits<typename RT::TableType>::enum_value;
    if (type != MessageData_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, MessageData type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  joescan::schema::update::server::InfoDataT *AsInfoData() {
    return type == MessageData_InfoData ?
      reinterpret_cast<joescan::schema::update::server::InfoDataT *>(value) : nullptr;
  }
  const joescan::schema::update::server::InfoDataT *AsInfoData() const {
    return type == MessageData_InfoData ?
      reinterpret_cast<const joescan::schema::update::server::InfoDataT *>(value) : nullptr;
  }
  joescan::schema::update::server::StatusDataT *AsStatusData() {
    return type == MessageData_StatusData ?
      reinterpret_cast<joescan::schema::update::server::StatusDataT *>(value) : nullptr;
  }
  const joescan::schema::update::server::StatusDataT *AsStatusData() const {
    return type == MessageData_StatusData ?
      reinterpret_cast<const joescan::schema::update::server::StatusDataT *>(value) : nullptr;
  }
};

bool VerifyMessageData(flatbuffers::Verifier &verifier, const void *obj, MessageData type);
bool VerifyMessageDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct InfoDataT : public flatbuffers::NativeTable {
  typedef InfoData TableType;
  uint32_t serial = 0;
  joescan::schema::ScanHeadType type = joescan::schema::ScanHeadType_INVALID;
  uint32_t version_major = 0;
  uint32_t version_minor = 0;
  uint32_t version_patch = 0;
  uint32_t version_commit = 0;
  uint32_t hardware_revision = 0;
  uint32_t max_transfer_bytes = 0;
};

struct InfoData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InfoDataT NativeTableType;
  typedef InfoDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SERIAL = 4,
    VT_TYPE = 6,
    VT_VERSION_MAJOR = 8,
    VT_VERSION_MINOR = 10,
    VT_VERSION_PATCH = 12,
    VT_VERSION_COMMIT = 14,
    VT_HARDWARE_REVISION = 16,
    VT_MAX_TRANSFER_BYTES = 18
  };
  uint32_t serial() const {
    return GetField<uint32_t>(VT_SERIAL, 0);
  }
  joescan::schema::ScanHeadType type() const {
    return static_cast<joescan::schema::ScanHeadType>(GetField<uint16_t>(VT_TYPE, 0));
  }
  uint32_t version_major() const {
    return GetField<uint32_t>(VT_VERSION_MAJOR, 0);
  }
  uint32_t version_minor() const {
    return GetField<uint32_t>(VT_VERSION_MINOR, 0);
  }
  uint32_t version_patch() const {
    return GetField<uint32_t>(VT_VERSION_PATCH, 0);
  }
  uint32_t version_commit() const {
    return GetField<uint32_t>(VT_VERSION_COMMIT, 0);
  }
  uint32_t hardware_revision() const {
    return GetField<uint32_t>(VT_HARDWARE_REVISION, 0);
  }
  uint32_t max_transfer_bytes() const {
    return GetField<uint32_t>(VT_MAX_TRANSFER_BYTES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SERIAL) &&
           VerifyField<uint16_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_VERSION_MAJOR) &&
           VerifyField<uint32_t>(verifier, VT_VERSION_MINOR) &&
           VerifyField<uint32_t>(verifier, VT_VERSION_PATCH) &&
           VerifyField<uint32_t>(verifier, VT_VERSION_COMMIT) &&
           VerifyField<uint32_t>(verifier, VT_HARDWARE_REVISION) &&
           VerifyField<uint32_t>(verifier, VT_MAX_TRANSFER_BYTES) &&
           verifier.EndTable();
  }
  InfoDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InfoDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InfoData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InfoDataBuilder {
  typedef InfoData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_serial(uint32_t serial) {
    fbb_.AddElement<uint32_t>(InfoData::VT_SERIAL, serial, 0);
  }
  void add_type(joescan::schema::ScanHeadType type) {
    fbb_.AddElement<uint16_t>(InfoData::VT_TYPE, static_cast<uint16_t>(type), 0);
  }
  void add_version_major(uint32_t version_major) {
    fbb_.AddElement<uint32_t>(InfoData::VT_VERSION_MAJOR, version_major, 0);
  }
  void add_version_minor(uint32_t version_minor) {
    fbb_.AddElement<uint32_t>(InfoData::VT_VERSION_MINOR, version_minor, 0);
  }
  void add_version_patch(uint32_t version_patch) {
    fbb_.AddElement<uint32_t>(InfoData::VT_VERSION_PATCH, version_patch, 0);
  }
  void add_version_commit(uint32_t version_commit) {
    fbb_.AddElement<uint32_t>(InfoData::VT_VERSION_COMMIT, version_commit, 0);
  }
  void add_hardware_revision(uint32_t hardware_revision) {
    fbb_.AddElement<uint32_t>(InfoData::VT_HARDWARE_REVISION, hardware_revision, 0);
  }
  void add_max_transfer_bytes(uint32_t max_transfer_bytes) {
    fbb_.AddElement<uint32_t>(InfoData::VT_MAX_TRANSFER_BYTES, max_transfer_bytes, 0);
  }
  explicit InfoDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InfoData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfoData>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfoData> CreateInfoData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t serial = 0,
    joescan::schema::ScanHeadType type = joescan::schema::ScanHeadType_INVALID,
    uint32_t version_major = 0,
    uint32_t version_minor = 0,
    uint32_t version_patch = 0,
    uint32_t version_commit = 0,
    uint32_t hardware_revision = 0,
    uint32_t max_transfer_bytes = 0) {
  InfoDataBuilder builder_(_fbb);
  builder_.add_max_transfer_bytes(max_transfer_bytes);
  builder_.add_hardware_revision(hardware_revision);
  builder_.add_version_commit(version_commit);
  builder_.add_version_patch(version_patch);
  builder_.add_version_minor(version_minor);
  builder_.add_version_major(version_major);
  builder_.add_serial(serial);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<InfoData> CreateInfoData(flatbuffers::FlatBufferBuilder &_fbb, const InfoDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StatusDataT : public flatbuffers::NativeTable {
  typedef StatusData TableType;
  joescan::schema::update::server::Status status = joescan::schema::update::server::Status_SUCCESS;
};

struct StatusData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusDataT NativeTableType;
  typedef StatusDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS = 4
  };
  joescan::schema::update::server::Status status() const {
    return static_cast<joescan::schema::update::server::Status>(GetField<uint16_t>(VT_STATUS, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_STATUS) &&
           verifier.EndTable();
  }
  StatusDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatusDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StatusData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatusDataBuilder {
  typedef StatusData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(joescan::schema::update::server::Status status) {
    fbb_.AddElement<uint16_t>(StatusData::VT_STATUS, static_cast<uint16_t>(status), 0);
  }
  explicit StatusDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusData>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusData> CreateStatusData(
    flatbuffers::FlatBufferBuilder &_fbb,
    joescan::schema::update::server::Status status = joescan::schema::update::server::Status_SUCCESS) {
  StatusDataBuilder builder_(_fbb);
  builder_.add_status(status);
  return builder_.Finish();
}

flatbuffers::Offset<StatusData> CreateStatusData(flatbuffers::FlatBufferBuilder &_fbb, const StatusDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageServerT : public flatbuffers::NativeTable {
  typedef MessageServer TableType;
  joescan::schema::update::server::MessageType type = joescan::schema::update::server::MessageType_NONE;
  joescan::schema::update::server::MessageDataUnion data{};
};

struct MessageServer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageServerT NativeTableType;
  typedef MessageServerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  joescan::schema::update::server::MessageType type() const {
    return static_cast<joescan::schema::update::server::MessageType>(GetField<uint16_t>(VT_TYPE, 0));
  }
  joescan::schema::update::server::MessageData data_type() const {
    return static_cast<joescan::schema::update::server::MessageData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const joescan::schema::update::server::InfoData *data_as_InfoData() const {
    return data_type() == joescan::schema::update::server::MessageData_InfoData ? static_cast<const joescan::schema::update::server::InfoData *>(data()) : nullptr;
  }
  const joescan::schema::update::server::StatusData *data_as_StatusData() const {
    return data_type() == joescan::schema::update::server::MessageData_StatusData ? static_cast<const joescan::schema::update::server::StatusData *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyMessageData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  MessageServerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageServerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageServer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageServerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const joescan::schema::update::server::InfoData *MessageServer::data_as<joescan::schema::update::server::InfoData>() const {
  return data_as_InfoData();
}

template<> inline const joescan::schema::update::server::StatusData *MessageServer::data_as<joescan::schema::update::server::StatusData>() const {
  return data_as_StatusData();
}

struct MessageServerBuilder {
  typedef MessageServer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(joescan::schema::update::server::MessageType type) {
    fbb_.AddElement<uint16_t>(MessageServer::VT_TYPE, static_cast<uint16_t>(type), 0);
  }
  void add_data_type(joescan::schema::update::server::MessageData data_type) {
    fbb_.AddElement<uint8_t>(MessageServer::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(MessageServer::VT_DATA, data);
  }
  explicit MessageServerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageServer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageServer>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageServer> CreateMessageServer(
    flatbuffers::FlatBufferBuilder &_fbb,
    joescan::schema::update::server::MessageType type = joescan::schema::update::server::MessageType_NONE,
    joescan::schema::update::server::MessageData data_type = joescan::schema::update::server::MessageData_NONE,
    flatbuffers::Offset<void> data = 0) {
  MessageServerBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

flatbuffers::Offset<MessageServer> CreateMessageServer(flatbuffers::FlatBufferBuilder &_fbb, const MessageServerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline InfoDataT *InfoData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InfoDataT>(new InfoDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InfoData::UnPackTo(InfoDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = serial(); _o->serial = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = version_major(); _o->version_major = _e; }
  { auto _e = version_minor(); _o->version_minor = _e; }
  { auto _e = version_patch(); _o->version_patch = _e; }
  { auto _e = version_commit(); _o->version_commit = _e; }
  { auto _e = hardware_revision(); _o->hardware_revision = _e; }
  { auto _e = max_transfer_bytes(); _o->max_transfer_bytes = _e; }
}

inline flatbuffers::Offset<InfoData> InfoData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInfoData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InfoData> CreateInfoData(flatbuffers::FlatBufferBuilder &_fbb, const InfoDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InfoDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _serial = _o->serial;
  auto _type = _o->type;
  auto _version_major = _o->version_major;
  auto _version_minor = _o->version_minor;
  auto _version_patch = _o->version_patch;
  auto _version_commit = _o->version_commit;
  auto _hardware_revision = _o->hardware_revision;
  auto _max_transfer_bytes = _o->max_transfer_bytes;
  return joescan::schema::update::server::CreateInfoData(
      _fbb,
      _serial,
      _type,
      _version_major,
      _version_minor,
      _version_patch,
      _version_commit,
      _hardware_revision,
      _max_transfer_bytes);
}

inline StatusDataT *StatusData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StatusDataT>(new StatusDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StatusData::UnPackTo(StatusDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = status(); _o->status = _e; }
}

inline flatbuffers::Offset<StatusData> StatusData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatusData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StatusData> CreateStatusData(flatbuffers::FlatBufferBuilder &_fbb, const StatusDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StatusDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _status = _o->status;
  return joescan::schema::update::server::CreateStatusData(
      _fbb,
      _status);
}

inline MessageServerT *MessageServer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MessageServerT>(new MessageServerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MessageServer::UnPackTo(MessageServerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = joescan::schema::update::server::MessageDataUnion::UnPack(_e, data_type(), _resolver); }
}

inline flatbuffers::Offset<MessageServer> MessageServer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageServerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageServer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageServer> CreateMessageServer(flatbuffers::FlatBufferBuilder &_fbb, const MessageServerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageServerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return joescan::schema::update::server::CreateMessageServer(
      _fbb,
      _type,
      _data_type,
      _data);
}

inline bool VerifyMessageData(flatbuffers::Verifier &verifier, const void *obj, MessageData type) {
  switch (type) {
    case MessageData_NONE: {
      return true;
    }
    case MessageData_InfoData: {
      auto ptr = reinterpret_cast<const joescan::schema::update::server::InfoData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_StatusData: {
      auto ptr = reinterpret_cast<const joescan::schema::update::server::StatusData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageData(
        verifier,  values->Get(i), types->GetEnum<MessageData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageDataUnion::UnPack(const void *obj, MessageData type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case MessageData_InfoData: {
      auto ptr = reinterpret_cast<const joescan::schema::update::server::InfoData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_StatusData: {
      auto ptr = reinterpret_cast<const joescan::schema::update::server::StatusData *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageDataUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case MessageData_InfoData: {
      auto ptr = reinterpret_cast<const joescan::schema::update::server::InfoDataT *>(value);
      return CreateInfoData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_StatusData: {
      auto ptr = reinterpret_cast<const joescan::schema::update::server::StatusDataT *>(value);
      return CreateStatusData(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageDataUnion::MessageDataUnion(const MessageDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case MessageData_InfoData: {
      value = new joescan::schema::update::server::InfoDataT(*reinterpret_cast<joescan::schema::update::server::InfoDataT *>(u.value));
      break;
    }
    case MessageData_StatusData: {
      value = new joescan::schema::update::server::StatusDataT(*reinterpret_cast<joescan::schema::update::server::StatusDataT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void MessageDataUnion::Reset() {
  switch (type) {
    case MessageData_InfoData: {
      auto ptr = reinterpret_cast<joescan::schema::update::server::InfoDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_StatusData: {
      auto ptr = reinterpret_cast<joescan::schema::update::server::StatusDataT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MessageData_NONE;
}

inline const joescan::schema::update::server::MessageServer *GetMessageServer(const void *buf) {
  return flatbuffers::GetRoot<joescan::schema::update::server::MessageServer>(buf);
}

inline const joescan::schema::update::server::MessageServer *GetSizePrefixedMessageServer(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<joescan::schema::update::server::MessageServer>(buf);
}

inline bool VerifyMessageServerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<joescan::schema::update::server::MessageServer>(nullptr);
}

inline bool VerifySizePrefixedMessageServerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<joescan::schema::update::server::MessageServer>(nullptr);
}

inline void FinishMessageServerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<joescan::schema::update::server::MessageServer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageServerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<joescan::schema::update::server::MessageServer> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<joescan::schema::update::server::MessageServerT> UnPackMessageServer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<joescan::schema::update::server::MessageServerT>(GetMessageServer(buf)->UnPack(res));
}

inline std::unique_ptr<joescan::schema::update::server::MessageServerT> UnPackSizePrefixedMessageServer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<joescan::schema::update::server::MessageServerT>(GetSizePrefixedMessageServer(buf)->UnPack(res));
}

}  // namespace server
}  // namespace update
}  // namespace schema
}  // namespace joescan

#endif  // FLATBUFFERS_GENERATED_MESSAGEUPDATESERVER_JOESCAN_SCHEMA_UPDATE_SERVER_H_
