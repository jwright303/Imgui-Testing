// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGEUPDATECLIENT_JOESCAN_SCHEMA_UPDATE_CLIENT_H_
#define FLATBUFFERS_GENERATED_MESSAGEUPDATECLIENT_JOESCAN_SCHEMA_UPDATE_CLIENT_H_

#include "flatbuffers/flatbuffers.h"

namespace joescan {
namespace schema {
namespace update {
namespace client {

struct FileData;
struct FileDataBuilder;
struct FileDataT;

struct MessageClient;
struct MessageClientBuilder;
struct MessageClientT;

enum MessageType : uint16_t {
  MessageType_NONE = 0,
  MessageType_INFO_REQUEST = 1,
  MessageType_FILE_TRANSFER_REQUEST = 2,
  MessageType_REBOOT_REQUEST = 3,
  MessageType_MIN = MessageType_NONE,
  MessageType_MAX = MessageType_REBOOT_REQUEST
};

inline const MessageType (&EnumValuesMessageType())[4] {
  static const MessageType values[] = {
    MessageType_NONE,
    MessageType_INFO_REQUEST,
    MessageType_FILE_TRANSFER_REQUEST,
    MessageType_REBOOT_REQUEST
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[5] = {
    "NONE",
    "INFO_REQUEST",
    "FILE_TRANSFER_REQUEST",
    "REBOOT_REQUEST",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (flatbuffers::IsOutRange(e, MessageType_NONE, MessageType_REBOOT_REQUEST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

enum MessageData : uint8_t {
  MessageData_NONE = 0,
  MessageData_FileData = 1,
  MessageData_MIN = MessageData_NONE,
  MessageData_MAX = MessageData_FileData
};

inline const MessageData (&EnumValuesMessageData())[2] {
  static const MessageData values[] = {
    MessageData_NONE,
    MessageData_FileData
  };
  return values;
}

inline const char * const *EnumNamesMessageData() {
  static const char * const names[3] = {
    "NONE",
    "FileData",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageData(MessageData e) {
  if (flatbuffers::IsOutRange(e, MessageData_NONE, MessageData_FileData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageData()[index];
}

template<typename T> struct MessageDataTraits {
  static const MessageData enum_value = MessageData_NONE;
};

template<> struct MessageDataTraits<joescan::schema::update::client::FileData> {
  static const MessageData enum_value = MessageData_FileData;
};

struct MessageDataUnion {
  MessageData type;
  void *value;

  MessageDataUnion() : type(MessageData_NONE), value(nullptr) {}
  MessageDataUnion(MessageDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MessageData_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageDataUnion(const MessageDataUnion &);
  MessageDataUnion &operator=(const MessageDataUnion &u)
    { MessageDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageDataUnion &operator=(MessageDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageDataUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = MessageDataTraits<typename RT::TableType>::enum_value;
    if (type != MessageData_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, MessageData type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  joescan::schema::update::client::FileDataT *AsFileData() {
    return type == MessageData_FileData ?
      reinterpret_cast<joescan::schema::update::client::FileDataT *>(value) : nullptr;
  }
  const joescan::schema::update::client::FileDataT *AsFileData() const {
    return type == MessageData_FileData ?
      reinterpret_cast<const joescan::schema::update::client::FileDataT *>(value) : nullptr;
  }
};

bool VerifyMessageData(flatbuffers::Verifier &verifier, const void *obj, MessageData type);
bool VerifyMessageDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct FileDataT : public flatbuffers::NativeTable {
  typedef FileData TableType;
  uint32_t chunk_count = 0;
  uint32_t chunk_total = 0;
  std::string file_name{};
  std::string file_md5{};
  std::vector<uint8_t> binary{};
};

struct FileData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileDataT NativeTableType;
  typedef FileDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHUNK_COUNT = 4,
    VT_CHUNK_TOTAL = 6,
    VT_FILE_NAME = 8,
    VT_FILE_MD5 = 10,
    VT_BINARY = 12
  };
  uint32_t chunk_count() const {
    return GetField<uint32_t>(VT_CHUNK_COUNT, 0);
  }
  uint32_t chunk_total() const {
    return GetField<uint32_t>(VT_CHUNK_TOTAL, 0);
  }
  const flatbuffers::String *file_name() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_NAME);
  }
  const flatbuffers::String *file_md5() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE_MD5);
  }
  const flatbuffers::Vector<uint8_t> *binary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BINARY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CHUNK_COUNT) &&
           VerifyField<uint32_t>(verifier, VT_CHUNK_TOTAL) &&
           VerifyOffset(verifier, VT_FILE_NAME) &&
           verifier.VerifyString(file_name()) &&
           VerifyOffset(verifier, VT_FILE_MD5) &&
           verifier.VerifyString(file_md5()) &&
           VerifyOffset(verifier, VT_BINARY) &&
           verifier.VerifyVector(binary()) &&
           verifier.EndTable();
  }
  FileDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FileDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FileData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FileDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FileDataBuilder {
  typedef FileData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chunk_count(uint32_t chunk_count) {
    fbb_.AddElement<uint32_t>(FileData::VT_CHUNK_COUNT, chunk_count, 0);
  }
  void add_chunk_total(uint32_t chunk_total) {
    fbb_.AddElement<uint32_t>(FileData::VT_CHUNK_TOTAL, chunk_total, 0);
  }
  void add_file_name(flatbuffers::Offset<flatbuffers::String> file_name) {
    fbb_.AddOffset(FileData::VT_FILE_NAME, file_name);
  }
  void add_file_md5(flatbuffers::Offset<flatbuffers::String> file_md5) {
    fbb_.AddOffset(FileData::VT_FILE_MD5, file_md5);
  }
  void add_binary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary) {
    fbb_.AddOffset(FileData::VT_BINARY, binary);
  }
  explicit FileDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FileData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileData>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileData> CreateFileData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t chunk_count = 0,
    uint32_t chunk_total = 0,
    flatbuffers::Offset<flatbuffers::String> file_name = 0,
    flatbuffers::Offset<flatbuffers::String> file_md5 = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> binary = 0) {
  FileDataBuilder builder_(_fbb);
  builder_.add_binary(binary);
  builder_.add_file_md5(file_md5);
  builder_.add_file_name(file_name);
  builder_.add_chunk_total(chunk_total);
  builder_.add_chunk_count(chunk_count);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileData> CreateFileDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t chunk_count = 0,
    uint32_t chunk_total = 0,
    const char *file_name = nullptr,
    const char *file_md5 = nullptr,
    const std::vector<uint8_t> *binary = nullptr) {
  auto file_name__ = file_name ? _fbb.CreateString(file_name) : 0;
  auto file_md5__ = file_md5 ? _fbb.CreateString(file_md5) : 0;
  auto binary__ = binary ? _fbb.CreateVector<uint8_t>(*binary) : 0;
  return joescan::schema::update::client::CreateFileData(
      _fbb,
      chunk_count,
      chunk_total,
      file_name__,
      file_md5__,
      binary__);
}

flatbuffers::Offset<FileData> CreateFileData(flatbuffers::FlatBufferBuilder &_fbb, const FileDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageClientT : public flatbuffers::NativeTable {
  typedef MessageClient TableType;
  joescan::schema::update::client::MessageType type = joescan::schema::update::client::MessageType_NONE;
  joescan::schema::update::client::MessageDataUnion data{};
};

struct MessageClient FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageClientT NativeTableType;
  typedef MessageClientBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  joescan::schema::update::client::MessageType type() const {
    return static_cast<joescan::schema::update::client::MessageType>(GetField<uint16_t>(VT_TYPE, 0));
  }
  joescan::schema::update::client::MessageData data_type() const {
    return static_cast<joescan::schema::update::client::MessageData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const joescan::schema::update::client::FileData *data_as_FileData() const {
    return data_type() == joescan::schema::update::client::MessageData_FileData ? static_cast<const joescan::schema::update::client::FileData *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyMessageData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  MessageClientT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageClientT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageClient> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageClientT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const joescan::schema::update::client::FileData *MessageClient::data_as<joescan::schema::update::client::FileData>() const {
  return data_as_FileData();
}

struct MessageClientBuilder {
  typedef MessageClient Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(joescan::schema::update::client::MessageType type) {
    fbb_.AddElement<uint16_t>(MessageClient::VT_TYPE, static_cast<uint16_t>(type), 0);
  }
  void add_data_type(joescan::schema::update::client::MessageData data_type) {
    fbb_.AddElement<uint8_t>(MessageClient::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(MessageClient::VT_DATA, data);
  }
  explicit MessageClientBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageClient> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageClient>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageClient> CreateMessageClient(
    flatbuffers::FlatBufferBuilder &_fbb,
    joescan::schema::update::client::MessageType type = joescan::schema::update::client::MessageType_NONE,
    joescan::schema::update::client::MessageData data_type = joescan::schema::update::client::MessageData_NONE,
    flatbuffers::Offset<void> data = 0) {
  MessageClientBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

flatbuffers::Offset<MessageClient> CreateMessageClient(flatbuffers::FlatBufferBuilder &_fbb, const MessageClientT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline FileDataT *FileData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FileDataT>(new FileDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FileData::UnPackTo(FileDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chunk_count(); _o->chunk_count = _e; }
  { auto _e = chunk_total(); _o->chunk_total = _e; }
  { auto _e = file_name(); if (_e) _o->file_name = _e->str(); }
  { auto _e = file_md5(); if (_e) _o->file_md5 = _e->str(); }
  { auto _e = binary(); if (_e) { _o->binary.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->binary.begin()); } }
}

inline flatbuffers::Offset<FileData> FileData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FileDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFileData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FileData> CreateFileData(flatbuffers::FlatBufferBuilder &_fbb, const FileDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FileDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chunk_count = _o->chunk_count;
  auto _chunk_total = _o->chunk_total;
  auto _file_name = _o->file_name.empty() ? 0 : _fbb.CreateString(_o->file_name);
  auto _file_md5 = _o->file_md5.empty() ? 0 : _fbb.CreateString(_o->file_md5);
  auto _binary = _o->binary.size() ? _fbb.CreateVector(_o->binary) : 0;
  return joescan::schema::update::client::CreateFileData(
      _fbb,
      _chunk_count,
      _chunk_total,
      _file_name,
      _file_md5,
      _binary);
}

inline MessageClientT *MessageClient::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MessageClientT>(new MessageClientT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MessageClient::UnPackTo(MessageClientT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = joescan::schema::update::client::MessageDataUnion::UnPack(_e, data_type(), _resolver); }
}

inline flatbuffers::Offset<MessageClient> MessageClient::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageClientT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageClient(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageClient> CreateMessageClient(flatbuffers::FlatBufferBuilder &_fbb, const MessageClientT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageClientT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return joescan::schema::update::client::CreateMessageClient(
      _fbb,
      _type,
      _data_type,
      _data);
}

inline bool VerifyMessageData(flatbuffers::Verifier &verifier, const void *obj, MessageData type) {
  switch (type) {
    case MessageData_NONE: {
      return true;
    }
    case MessageData_FileData: {
      auto ptr = reinterpret_cast<const joescan::schema::update::client::FileData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageData(
        verifier,  values->Get(i), types->GetEnum<MessageData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageDataUnion::UnPack(const void *obj, MessageData type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case MessageData_FileData: {
      auto ptr = reinterpret_cast<const joescan::schema::update::client::FileData *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageDataUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case MessageData_FileData: {
      auto ptr = reinterpret_cast<const joescan::schema::update::client::FileDataT *>(value);
      return CreateFileData(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageDataUnion::MessageDataUnion(const MessageDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case MessageData_FileData: {
      value = new joescan::schema::update::client::FileDataT(*reinterpret_cast<joescan::schema::update::client::FileDataT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void MessageDataUnion::Reset() {
  switch (type) {
    case MessageData_FileData: {
      auto ptr = reinterpret_cast<joescan::schema::update::client::FileDataT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MessageData_NONE;
}

inline const joescan::schema::update::client::MessageClient *GetMessageClient(const void *buf) {
  return flatbuffers::GetRoot<joescan::schema::update::client::MessageClient>(buf);
}

inline const joescan::schema::update::client::MessageClient *GetSizePrefixedMessageClient(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<joescan::schema::update::client::MessageClient>(buf);
}

inline bool VerifyMessageClientBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<joescan::schema::update::client::MessageClient>(nullptr);
}

inline bool VerifySizePrefixedMessageClientBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<joescan::schema::update::client::MessageClient>(nullptr);
}

inline void FinishMessageClientBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<joescan::schema::update::client::MessageClient> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageClientBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<joescan::schema::update::client::MessageClient> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<joescan::schema::update::client::MessageClientT> UnPackMessageClient(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<joescan::schema::update::client::MessageClientT>(GetMessageClient(buf)->UnPack(res));
}

inline std::unique_ptr<joescan::schema::update::client::MessageClientT> UnPackSizePrefixedMessageClient(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<joescan::schema::update::client::MessageClientT>(GetSizePrefixedMessageClient(buf)->UnPack(res));
}

}  // namespace client
}  // namespace update
}  // namespace schema
}  // namespace joescan

#endif  // FLATBUFFERS_GENERATED_MESSAGEUPDATECLIENT_JOESCAN_SCHEMA_UPDATE_CLIENT_H_
