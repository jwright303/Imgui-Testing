// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGESERVER_JOESCAN_SCHEMA_SERVER_H_
#define FLATBUFFERS_GENERATED_MESSAGESERVER_JOESCAN_SCHEMA_SERVER_H_

#include "flatbuffers/flatbuffers.h"

#include "ScanHeadType_generated.h"

namespace joescan {
namespace schema {
namespace server {

struct Peaks;

struct ProfilePoint;

struct ImageData;
struct ImageDataBuilder;
struct ImageDataT;

struct ProfileData;
struct ProfileDataBuilder;
struct ProfileDataT;

struct CameraData;
struct CameraDataBuilder;
struct CameraDataT;

struct StatusData;
struct StatusDataBuilder;
struct StatusDataT;

struct MappleData;
struct MappleDataBuilder;
struct MappleDataT;

struct MessageServer;
struct MessageServerBuilder;
struct MessageServerT;

enum MessageType : uint16_t {
  MessageType_NONE = 0,
  MessageType_STATUS = 1,
  MessageType_IMAGE = 2,
  MessageType_MAPPLE_DATA = 3,
  MessageType_PROFILE = 4,
  MessageType_MIN = MessageType_NONE,
  MessageType_MAX = MessageType_PROFILE
};

inline const MessageType (&EnumValuesMessageType())[5] {
  static const MessageType values[] = {
    MessageType_NONE,
    MessageType_STATUS,
    MessageType_IMAGE,
    MessageType_MAPPLE_DATA,
    MessageType_PROFILE
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[6] = {
    "NONE",
    "STATUS",
    "IMAGE",
    "MAPPLE_DATA",
    "PROFILE",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (flatbuffers::IsOutRange(e, MessageType_NONE, MessageType_PROFILE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

enum MessageData : uint8_t {
  MessageData_NONE = 0,
  MessageData_ImageData = 1,
  MessageData_StatusData = 2,
  MessageData_MappleData = 3,
  MessageData_ProfileData = 4,
  MessageData_MIN = MessageData_NONE,
  MessageData_MAX = MessageData_ProfileData
};

inline const MessageData (&EnumValuesMessageData())[5] {
  static const MessageData values[] = {
    MessageData_NONE,
    MessageData_ImageData,
    MessageData_StatusData,
    MessageData_MappleData,
    MessageData_ProfileData
  };
  return values;
}

inline const char * const *EnumNamesMessageData() {
  static const char * const names[6] = {
    "NONE",
    "ImageData",
    "StatusData",
    "MappleData",
    "ProfileData",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageData(MessageData e) {
  if (flatbuffers::IsOutRange(e, MessageData_NONE, MessageData_ProfileData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageData()[index];
}

template<typename T> struct MessageDataTraits {
  static const MessageData enum_value = MessageData_NONE;
};

template<> struct MessageDataTraits<joescan::schema::server::ImageData> {
  static const MessageData enum_value = MessageData_ImageData;
};

template<> struct MessageDataTraits<joescan::schema::server::StatusData> {
  static const MessageData enum_value = MessageData_StatusData;
};

template<> struct MessageDataTraits<joescan::schema::server::MappleData> {
  static const MessageData enum_value = MessageData_MappleData;
};

template<> struct MessageDataTraits<joescan::schema::server::ProfileData> {
  static const MessageData enum_value = MessageData_ProfileData;
};

struct MessageDataUnion {
  MessageData type;
  void *value;

  MessageDataUnion() : type(MessageData_NONE), value(nullptr) {}
  MessageDataUnion(MessageDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MessageData_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageDataUnion(const MessageDataUnion &);
  MessageDataUnion &operator=(const MessageDataUnion &u)
    { MessageDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageDataUnion &operator=(MessageDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageDataUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = MessageDataTraits<typename RT::TableType>::enum_value;
    if (type != MessageData_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, MessageData type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  joescan::schema::server::ImageDataT *AsImageData() {
    return type == MessageData_ImageData ?
      reinterpret_cast<joescan::schema::server::ImageDataT *>(value) : nullptr;
  }
  const joescan::schema::server::ImageDataT *AsImageData() const {
    return type == MessageData_ImageData ?
      reinterpret_cast<const joescan::schema::server::ImageDataT *>(value) : nullptr;
  }
  joescan::schema::server::StatusDataT *AsStatusData() {
    return type == MessageData_StatusData ?
      reinterpret_cast<joescan::schema::server::StatusDataT *>(value) : nullptr;
  }
  const joescan::schema::server::StatusDataT *AsStatusData() const {
    return type == MessageData_StatusData ?
      reinterpret_cast<const joescan::schema::server::StatusDataT *>(value) : nullptr;
  }
  joescan::schema::server::MappleDataT *AsMappleData() {
    return type == MessageData_MappleData ?
      reinterpret_cast<joescan::schema::server::MappleDataT *>(value) : nullptr;
  }
  const joescan::schema::server::MappleDataT *AsMappleData() const {
    return type == MessageData_MappleData ?
      reinterpret_cast<const joescan::schema::server::MappleDataT *>(value) : nullptr;
  }
  joescan::schema::server::ProfileDataT *AsProfileData() {
    return type == MessageData_ProfileData ?
      reinterpret_cast<joescan::schema::server::ProfileDataT *>(value) : nullptr;
  }
  const joescan::schema::server::ProfileDataT *AsProfileData() const {
    return type == MessageData_ProfileData ?
      reinterpret_cast<const joescan::schema::server::ProfileDataT *>(value) : nullptr;
  }
};

bool VerifyMessageData(flatbuffers::Verifier &verifier, const void *obj, MessageData type);
bool VerifyMessageDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) Peaks FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t subpixel_;
  uint16_t brightness_;

 public:
  Peaks()
      : subpixel_(0),
        brightness_(0) {
  }
  Peaks(uint16_t _subpixel, uint16_t _brightness)
      : subpixel_(flatbuffers::EndianScalar(_subpixel)),
        brightness_(flatbuffers::EndianScalar(_brightness)) {
  }
  uint16_t subpixel() const {
    return flatbuffers::EndianScalar(subpixel_);
  }
  uint16_t brightness() const {
    return flatbuffers::EndianScalar(brightness_);
  }
};
FLATBUFFERS_STRUCT_END(Peaks, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) ProfilePoint FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t x_;
  int16_t y_;
  uint16_t brightness_;

 public:
  ProfilePoint()
      : x_(0),
        y_(0),
        brightness_(0) {
  }
  ProfilePoint(int16_t _x, int16_t _y, uint16_t _brightness)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        brightness_(flatbuffers::EndianScalar(_brightness)) {
  }
  int16_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int16_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  uint16_t brightness() const {
    return flatbuffers::EndianScalar(brightness_);
  }
};
FLATBUFFERS_STRUCT_END(ProfilePoint, 6);

struct ImageDataT : public flatbuffers::NativeTable {
  typedef ImageData TableType;
  uint64_t timestamp_ns = 0;
  uint32_t camera_port = 0;
  uint32_t laser_port = 0;
  uint32_t camera_exposure_ns = 0;
  uint32_t laser_on_time_ns = 0;
  uint32_t height = 0;
  uint32_t width = 0;
  std::vector<uint8_t> pixels{};
  std::vector<joescan::schema::server::Peaks> peaks{};
  std::vector<int64_t> encoders{};
};

struct ImageData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ImageDataT NativeTableType;
  typedef ImageDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP_NS = 4,
    VT_CAMERA_PORT = 6,
    VT_LASER_PORT = 8,
    VT_CAMERA_EXPOSURE_NS = 10,
    VT_LASER_ON_TIME_NS = 12,
    VT_HEIGHT = 14,
    VT_WIDTH = 16,
    VT_PIXELS = 18,
    VT_PEAKS = 20,
    VT_ENCODERS = 22
  };
  uint64_t timestamp_ns() const {
    return GetField<uint64_t>(VT_TIMESTAMP_NS, 0);
  }
  uint32_t camera_port() const {
    return GetField<uint32_t>(VT_CAMERA_PORT, 0);
  }
  uint32_t laser_port() const {
    return GetField<uint32_t>(VT_LASER_PORT, 0);
  }
  uint32_t camera_exposure_ns() const {
    return GetField<uint32_t>(VT_CAMERA_EXPOSURE_NS, 0);
  }
  uint32_t laser_on_time_ns() const {
    return GetField<uint32_t>(VT_LASER_ON_TIME_NS, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  const flatbuffers::Vector<uint8_t> *pixels() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PIXELS);
  }
  const flatbuffers::Vector<const joescan::schema::server::Peaks *> *peaks() const {
    return GetPointer<const flatbuffers::Vector<const joescan::schema::server::Peaks *> *>(VT_PEAKS);
  }
  const flatbuffers::Vector<int64_t> *encoders() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ENCODERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP_NS) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_PORT) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_EXPOSURE_NS) &&
           VerifyField<uint32_t>(verifier, VT_LASER_ON_TIME_NS) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyOffset(verifier, VT_PIXELS) &&
           verifier.VerifyVector(pixels()) &&
           VerifyOffset(verifier, VT_PEAKS) &&
           verifier.VerifyVector(peaks()) &&
           VerifyOffset(verifier, VT_ENCODERS) &&
           verifier.VerifyVector(encoders()) &&
           verifier.EndTable();
  }
  ImageDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ImageDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ImageData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ImageDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ImageDataBuilder {
  typedef ImageData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp_ns(uint64_t timestamp_ns) {
    fbb_.AddElement<uint64_t>(ImageData::VT_TIMESTAMP_NS, timestamp_ns, 0);
  }
  void add_camera_port(uint32_t camera_port) {
    fbb_.AddElement<uint32_t>(ImageData::VT_CAMERA_PORT, camera_port, 0);
  }
  void add_laser_port(uint32_t laser_port) {
    fbb_.AddElement<uint32_t>(ImageData::VT_LASER_PORT, laser_port, 0);
  }
  void add_camera_exposure_ns(uint32_t camera_exposure_ns) {
    fbb_.AddElement<uint32_t>(ImageData::VT_CAMERA_EXPOSURE_NS, camera_exposure_ns, 0);
  }
  void add_laser_on_time_ns(uint32_t laser_on_time_ns) {
    fbb_.AddElement<uint32_t>(ImageData::VT_LASER_ON_TIME_NS, laser_on_time_ns, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(ImageData::VT_HEIGHT, height, 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(ImageData::VT_WIDTH, width, 0);
  }
  void add_pixels(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pixels) {
    fbb_.AddOffset(ImageData::VT_PIXELS, pixels);
  }
  void add_peaks(flatbuffers::Offset<flatbuffers::Vector<const joescan::schema::server::Peaks *>> peaks) {
    fbb_.AddOffset(ImageData::VT_PEAKS, peaks);
  }
  void add_encoders(flatbuffers::Offset<flatbuffers::Vector<int64_t>> encoders) {
    fbb_.AddOffset(ImageData::VT_ENCODERS, encoders);
  }
  explicit ImageDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ImageData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ImageData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ImageData> CreateImageData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp_ns = 0,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    uint32_t camera_exposure_ns = 0,
    uint32_t laser_on_time_ns = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> pixels = 0,
    flatbuffers::Offset<flatbuffers::Vector<const joescan::schema::server::Peaks *>> peaks = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> encoders = 0) {
  ImageDataBuilder builder_(_fbb);
  builder_.add_timestamp_ns(timestamp_ns);
  builder_.add_encoders(encoders);
  builder_.add_peaks(peaks);
  builder_.add_pixels(pixels);
  builder_.add_width(width);
  builder_.add_height(height);
  builder_.add_laser_on_time_ns(laser_on_time_ns);
  builder_.add_camera_exposure_ns(camera_exposure_ns);
  builder_.add_laser_port(laser_port);
  builder_.add_camera_port(camera_port);
  return builder_.Finish();
}

inline flatbuffers::Offset<ImageData> CreateImageDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp_ns = 0,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    uint32_t camera_exposure_ns = 0,
    uint32_t laser_on_time_ns = 0,
    uint32_t height = 0,
    uint32_t width = 0,
    const std::vector<uint8_t> *pixels = nullptr,
    const std::vector<joescan::schema::server::Peaks> *peaks = nullptr,
    const std::vector<int64_t> *encoders = nullptr) {
  auto pixels__ = pixels ? _fbb.CreateVector<uint8_t>(*pixels) : 0;
  auto peaks__ = peaks ? _fbb.CreateVectorOfStructs<joescan::schema::server::Peaks>(*peaks) : 0;
  auto encoders__ = encoders ? _fbb.CreateVector<int64_t>(*encoders) : 0;
  return joescan::schema::server::CreateImageData(
      _fbb,
      timestamp_ns,
      camera_port,
      laser_port,
      camera_exposure_ns,
      laser_on_time_ns,
      height,
      width,
      pixels__,
      peaks__,
      encoders__);
}

flatbuffers::Offset<ImageData> CreateImageData(flatbuffers::FlatBufferBuilder &_fbb, const ImageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProfileDataT : public flatbuffers::NativeTable {
  typedef ProfileData TableType;
  uint64_t timestamp_ns = 0;
  uint32_t camera_port = 0;
  uint32_t laser_port = 0;
  uint32_t camera_exposure_ns = 0;
  uint32_t laser_on_time_ns = 0;
  uint32_t valid_points = 0;
  std::vector<joescan::schema::server::ProfilePoint> points{};
  std::vector<int64_t> encoders{};
};

struct ProfileData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProfileDataT NativeTableType;
  typedef ProfileDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP_NS = 4,
    VT_CAMERA_PORT = 6,
    VT_LASER_PORT = 8,
    VT_CAMERA_EXPOSURE_NS = 10,
    VT_LASER_ON_TIME_NS = 12,
    VT_VALID_POINTS = 14,
    VT_POINTS = 16,
    VT_ENCODERS = 18
  };
  uint64_t timestamp_ns() const {
    return GetField<uint64_t>(VT_TIMESTAMP_NS, 0);
  }
  uint32_t camera_port() const {
    return GetField<uint32_t>(VT_CAMERA_PORT, 0);
  }
  uint32_t laser_port() const {
    return GetField<uint32_t>(VT_LASER_PORT, 0);
  }
  uint32_t camera_exposure_ns() const {
    return GetField<uint32_t>(VT_CAMERA_EXPOSURE_NS, 0);
  }
  uint32_t laser_on_time_ns() const {
    return GetField<uint32_t>(VT_LASER_ON_TIME_NS, 0);
  }
  uint32_t valid_points() const {
    return GetField<uint32_t>(VT_VALID_POINTS, 0);
  }
  const flatbuffers::Vector<const joescan::schema::server::ProfilePoint *> *points() const {
    return GetPointer<const flatbuffers::Vector<const joescan::schema::server::ProfilePoint *> *>(VT_POINTS);
  }
  const flatbuffers::Vector<int64_t> *encoders() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ENCODERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TIMESTAMP_NS) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_PORT) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_EXPOSURE_NS) &&
           VerifyField<uint32_t>(verifier, VT_LASER_ON_TIME_NS) &&
           VerifyField<uint32_t>(verifier, VT_VALID_POINTS) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           VerifyOffset(verifier, VT_ENCODERS) &&
           verifier.VerifyVector(encoders()) &&
           verifier.EndTable();
  }
  ProfileDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProfileDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProfileData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProfileDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProfileDataBuilder {
  typedef ProfileData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp_ns(uint64_t timestamp_ns) {
    fbb_.AddElement<uint64_t>(ProfileData::VT_TIMESTAMP_NS, timestamp_ns, 0);
  }
  void add_camera_port(uint32_t camera_port) {
    fbb_.AddElement<uint32_t>(ProfileData::VT_CAMERA_PORT, camera_port, 0);
  }
  void add_laser_port(uint32_t laser_port) {
    fbb_.AddElement<uint32_t>(ProfileData::VT_LASER_PORT, laser_port, 0);
  }
  void add_camera_exposure_ns(uint32_t camera_exposure_ns) {
    fbb_.AddElement<uint32_t>(ProfileData::VT_CAMERA_EXPOSURE_NS, camera_exposure_ns, 0);
  }
  void add_laser_on_time_ns(uint32_t laser_on_time_ns) {
    fbb_.AddElement<uint32_t>(ProfileData::VT_LASER_ON_TIME_NS, laser_on_time_ns, 0);
  }
  void add_valid_points(uint32_t valid_points) {
    fbb_.AddElement<uint32_t>(ProfileData::VT_VALID_POINTS, valid_points, 0);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const joescan::schema::server::ProfilePoint *>> points) {
    fbb_.AddOffset(ProfileData::VT_POINTS, points);
  }
  void add_encoders(flatbuffers::Offset<flatbuffers::Vector<int64_t>> encoders) {
    fbb_.AddOffset(ProfileData::VT_ENCODERS, encoders);
  }
  explicit ProfileDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProfileData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProfileData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProfileData> CreateProfileData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp_ns = 0,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    uint32_t camera_exposure_ns = 0,
    uint32_t laser_on_time_ns = 0,
    uint32_t valid_points = 0,
    flatbuffers::Offset<flatbuffers::Vector<const joescan::schema::server::ProfilePoint *>> points = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> encoders = 0) {
  ProfileDataBuilder builder_(_fbb);
  builder_.add_timestamp_ns(timestamp_ns);
  builder_.add_encoders(encoders);
  builder_.add_points(points);
  builder_.add_valid_points(valid_points);
  builder_.add_laser_on_time_ns(laser_on_time_ns);
  builder_.add_camera_exposure_ns(camera_exposure_ns);
  builder_.add_laser_port(laser_port);
  builder_.add_camera_port(camera_port);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProfileData> CreateProfileDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t timestamp_ns = 0,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    uint32_t camera_exposure_ns = 0,
    uint32_t laser_on_time_ns = 0,
    uint32_t valid_points = 0,
    const std::vector<joescan::schema::server::ProfilePoint> *points = nullptr,
    const std::vector<int64_t> *encoders = nullptr) {
  auto points__ = points ? _fbb.CreateVectorOfStructs<joescan::schema::server::ProfilePoint>(*points) : 0;
  auto encoders__ = encoders ? _fbb.CreateVector<int64_t>(*encoders) : 0;
  return joescan::schema::server::CreateProfileData(
      _fbb,
      timestamp_ns,
      camera_port,
      laser_port,
      camera_exposure_ns,
      laser_on_time_ns,
      valid_points,
      points__,
      encoders__);
}

flatbuffers::Offset<ProfileData> CreateProfileData(flatbuffers::FlatBufferBuilder &_fbb, const ProfileDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CameraDataT : public flatbuffers::NativeTable {
  typedef CameraData TableType;
  uint32_t port = 0;
  uint32_t pixels_in_window = 0;
  uint32_t temperature = 0;
};

struct CameraData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CameraDataT NativeTableType;
  typedef CameraDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PORT = 4,
    VT_PIXELS_IN_WINDOW = 6,
    VT_TEMPERATURE = 8
  };
  uint32_t port() const {
    return GetField<uint32_t>(VT_PORT, 0);
  }
  uint32_t pixels_in_window() const {
    return GetField<uint32_t>(VT_PIXELS_IN_WINDOW, 0);
  }
  uint32_t temperature() const {
    return GetField<uint32_t>(VT_TEMPERATURE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PORT) &&
           VerifyField<uint32_t>(verifier, VT_PIXELS_IN_WINDOW) &&
           VerifyField<uint32_t>(verifier, VT_TEMPERATURE) &&
           verifier.EndTable();
  }
  CameraDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CameraDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CameraData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CameraDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CameraDataBuilder {
  typedef CameraData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_port(uint32_t port) {
    fbb_.AddElement<uint32_t>(CameraData::VT_PORT, port, 0);
  }
  void add_pixels_in_window(uint32_t pixels_in_window) {
    fbb_.AddElement<uint32_t>(CameraData::VT_PIXELS_IN_WINDOW, pixels_in_window, 0);
  }
  void add_temperature(uint32_t temperature) {
    fbb_.AddElement<uint32_t>(CameraData::VT_TEMPERATURE, temperature, 0);
  }
  explicit CameraDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CameraData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CameraData>(end);
    return o;
  }
};

inline flatbuffers::Offset<CameraData> CreateCameraData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t port = 0,
    uint32_t pixels_in_window = 0,
    uint32_t temperature = 0) {
  CameraDataBuilder builder_(_fbb);
  builder_.add_temperature(temperature);
  builder_.add_pixels_in_window(pixels_in_window);
  builder_.add_port(port);
  return builder_.Finish();
}

flatbuffers::Offset<CameraData> CreateCameraData(flatbuffers::FlatBufferBuilder &_fbb, const CameraDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StatusDataT : public flatbuffers::NativeTable {
  typedef StatusData TableType;
  uint32_t min_scan_period_ns = 0;
  uint64_t global_time_ns = 0;
  uint32_t num_packets_sent = 0;
  uint32_t num_profiles_sent = 0;
  std::vector<int64_t> encoders{};
  std::vector<std::unique_ptr<joescan::schema::server::CameraDataT>> camera_data{};
};

struct StatusData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatusDataT NativeTableType;
  typedef StatusDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_SCAN_PERIOD_NS = 4,
    VT_GLOBAL_TIME_NS = 6,
    VT_NUM_PACKETS_SENT = 8,
    VT_NUM_PROFILES_SENT = 10,
    VT_ENCODERS = 12,
    VT_CAMERA_DATA = 14
  };
  uint32_t min_scan_period_ns() const {
    return GetField<uint32_t>(VT_MIN_SCAN_PERIOD_NS, 0);
  }
  uint64_t global_time_ns() const {
    return GetField<uint64_t>(VT_GLOBAL_TIME_NS, 0);
  }
  uint32_t num_packets_sent() const {
    return GetField<uint32_t>(VT_NUM_PACKETS_SENT, 0);
  }
  uint32_t num_profiles_sent() const {
    return GetField<uint32_t>(VT_NUM_PROFILES_SENT, 0);
  }
  const flatbuffers::Vector<int64_t> *encoders() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ENCODERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<joescan::schema::server::CameraData>> *camera_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<joescan::schema::server::CameraData>> *>(VT_CAMERA_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MIN_SCAN_PERIOD_NS) &&
           VerifyField<uint64_t>(verifier, VT_GLOBAL_TIME_NS) &&
           VerifyField<uint32_t>(verifier, VT_NUM_PACKETS_SENT) &&
           VerifyField<uint32_t>(verifier, VT_NUM_PROFILES_SENT) &&
           VerifyOffset(verifier, VT_ENCODERS) &&
           verifier.VerifyVector(encoders()) &&
           VerifyOffset(verifier, VT_CAMERA_DATA) &&
           verifier.VerifyVector(camera_data()) &&
           verifier.VerifyVectorOfTables(camera_data()) &&
           verifier.EndTable();
  }
  StatusDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatusDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StatusData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatusDataBuilder {
  typedef StatusData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_scan_period_ns(uint32_t min_scan_period_ns) {
    fbb_.AddElement<uint32_t>(StatusData::VT_MIN_SCAN_PERIOD_NS, min_scan_period_ns, 0);
  }
  void add_global_time_ns(uint64_t global_time_ns) {
    fbb_.AddElement<uint64_t>(StatusData::VT_GLOBAL_TIME_NS, global_time_ns, 0);
  }
  void add_num_packets_sent(uint32_t num_packets_sent) {
    fbb_.AddElement<uint32_t>(StatusData::VT_NUM_PACKETS_SENT, num_packets_sent, 0);
  }
  void add_num_profiles_sent(uint32_t num_profiles_sent) {
    fbb_.AddElement<uint32_t>(StatusData::VT_NUM_PROFILES_SENT, num_profiles_sent, 0);
  }
  void add_encoders(flatbuffers::Offset<flatbuffers::Vector<int64_t>> encoders) {
    fbb_.AddOffset(StatusData::VT_ENCODERS, encoders);
  }
  void add_camera_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<joescan::schema::server::CameraData>>> camera_data) {
    fbb_.AddOffset(StatusData::VT_CAMERA_DATA, camera_data);
  }
  explicit StatusDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatusData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatusData>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatusData> CreateStatusData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t min_scan_period_ns = 0,
    uint64_t global_time_ns = 0,
    uint32_t num_packets_sent = 0,
    uint32_t num_profiles_sent = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> encoders = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<joescan::schema::server::CameraData>>> camera_data = 0) {
  StatusDataBuilder builder_(_fbb);
  builder_.add_global_time_ns(global_time_ns);
  builder_.add_camera_data(camera_data);
  builder_.add_encoders(encoders);
  builder_.add_num_profiles_sent(num_profiles_sent);
  builder_.add_num_packets_sent(num_packets_sent);
  builder_.add_min_scan_period_ns(min_scan_period_ns);
  return builder_.Finish();
}

inline flatbuffers::Offset<StatusData> CreateStatusDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t min_scan_period_ns = 0,
    uint64_t global_time_ns = 0,
    uint32_t num_packets_sent = 0,
    uint32_t num_profiles_sent = 0,
    const std::vector<int64_t> *encoders = nullptr,
    const std::vector<flatbuffers::Offset<joescan::schema::server::CameraData>> *camera_data = nullptr) {
  auto encoders__ = encoders ? _fbb.CreateVector<int64_t>(*encoders) : 0;
  auto camera_data__ = camera_data ? _fbb.CreateVector<flatbuffers::Offset<joescan::schema::server::CameraData>>(*camera_data) : 0;
  return joescan::schema::server::CreateStatusData(
      _fbb,
      min_scan_period_ns,
      global_time_ns,
      num_packets_sent,
      num_profiles_sent,
      encoders__,
      camera_data__);
}

flatbuffers::Offset<StatusData> CreateStatusData(flatbuffers::FlatBufferBuilder &_fbb, const StatusDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MappleDataT : public flatbuffers::NativeTable {
  typedef MappleData TableType;
  std::vector<int16_t> x_values{};
  std::vector<int16_t> y_values{};
  std::vector<uint8_t> window_bitmap{};
};

struct MappleData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MappleDataT NativeTableType;
  typedef MappleDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_VALUES = 4,
    VT_Y_VALUES = 6,
    VT_WINDOW_BITMAP = 8
  };
  const flatbuffers::Vector<int16_t> *x_values() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_X_VALUES);
  }
  const flatbuffers::Vector<int16_t> *y_values() const {
    return GetPointer<const flatbuffers::Vector<int16_t> *>(VT_Y_VALUES);
  }
  const flatbuffers::Vector<uint8_t> *window_bitmap() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_WINDOW_BITMAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_X_VALUES) &&
           verifier.VerifyVector(x_values()) &&
           VerifyOffset(verifier, VT_Y_VALUES) &&
           verifier.VerifyVector(y_values()) &&
           VerifyOffset(verifier, VT_WINDOW_BITMAP) &&
           verifier.VerifyVector(window_bitmap()) &&
           verifier.EndTable();
  }
  MappleDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MappleDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MappleData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MappleDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MappleDataBuilder {
  typedef MappleData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x_values(flatbuffers::Offset<flatbuffers::Vector<int16_t>> x_values) {
    fbb_.AddOffset(MappleData::VT_X_VALUES, x_values);
  }
  void add_y_values(flatbuffers::Offset<flatbuffers::Vector<int16_t>> y_values) {
    fbb_.AddOffset(MappleData::VT_Y_VALUES, y_values);
  }
  void add_window_bitmap(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> window_bitmap) {
    fbb_.AddOffset(MappleData::VT_WINDOW_BITMAP, window_bitmap);
  }
  explicit MappleDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MappleData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MappleData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MappleData> CreateMappleData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> x_values = 0,
    flatbuffers::Offset<flatbuffers::Vector<int16_t>> y_values = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> window_bitmap = 0) {
  MappleDataBuilder builder_(_fbb);
  builder_.add_window_bitmap(window_bitmap);
  builder_.add_y_values(y_values);
  builder_.add_x_values(x_values);
  return builder_.Finish();
}

inline flatbuffers::Offset<MappleData> CreateMappleDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *x_values = nullptr,
    const std::vector<int16_t> *y_values = nullptr,
    const std::vector<uint8_t> *window_bitmap = nullptr) {
  auto x_values__ = x_values ? _fbb.CreateVector<int16_t>(*x_values) : 0;
  auto y_values__ = y_values ? _fbb.CreateVector<int16_t>(*y_values) : 0;
  auto window_bitmap__ = window_bitmap ? _fbb.CreateVector<uint8_t>(*window_bitmap) : 0;
  return joescan::schema::server::CreateMappleData(
      _fbb,
      x_values__,
      y_values__,
      window_bitmap__);
}

flatbuffers::Offset<MappleData> CreateMappleData(flatbuffers::FlatBufferBuilder &_fbb, const MappleDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageServerT : public flatbuffers::NativeTable {
  typedef MessageServer TableType;
  joescan::schema::server::MessageType type = joescan::schema::server::MessageType_NONE;
  joescan::schema::server::MessageDataUnion data{};
};

struct MessageServer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageServerT NativeTableType;
  typedef MessageServerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  joescan::schema::server::MessageType type() const {
    return static_cast<joescan::schema::server::MessageType>(GetField<uint16_t>(VT_TYPE, 0));
  }
  joescan::schema::server::MessageData data_type() const {
    return static_cast<joescan::schema::server::MessageData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const joescan::schema::server::ImageData *data_as_ImageData() const {
    return data_type() == joescan::schema::server::MessageData_ImageData ? static_cast<const joescan::schema::server::ImageData *>(data()) : nullptr;
  }
  const joescan::schema::server::StatusData *data_as_StatusData() const {
    return data_type() == joescan::schema::server::MessageData_StatusData ? static_cast<const joescan::schema::server::StatusData *>(data()) : nullptr;
  }
  const joescan::schema::server::MappleData *data_as_MappleData() const {
    return data_type() == joescan::schema::server::MessageData_MappleData ? static_cast<const joescan::schema::server::MappleData *>(data()) : nullptr;
  }
  const joescan::schema::server::ProfileData *data_as_ProfileData() const {
    return data_type() == joescan::schema::server::MessageData_ProfileData ? static_cast<const joescan::schema::server::ProfileData *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyMessageData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  MessageServerT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageServerT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageServer> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageServerT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const joescan::schema::server::ImageData *MessageServer::data_as<joescan::schema::server::ImageData>() const {
  return data_as_ImageData();
}

template<> inline const joescan::schema::server::StatusData *MessageServer::data_as<joescan::schema::server::StatusData>() const {
  return data_as_StatusData();
}

template<> inline const joescan::schema::server::MappleData *MessageServer::data_as<joescan::schema::server::MappleData>() const {
  return data_as_MappleData();
}

template<> inline const joescan::schema::server::ProfileData *MessageServer::data_as<joescan::schema::server::ProfileData>() const {
  return data_as_ProfileData();
}

struct MessageServerBuilder {
  typedef MessageServer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(joescan::schema::server::MessageType type) {
    fbb_.AddElement<uint16_t>(MessageServer::VT_TYPE, static_cast<uint16_t>(type), 0);
  }
  void add_data_type(joescan::schema::server::MessageData data_type) {
    fbb_.AddElement<uint8_t>(MessageServer::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(MessageServer::VT_DATA, data);
  }
  explicit MessageServerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageServer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageServer>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageServer> CreateMessageServer(
    flatbuffers::FlatBufferBuilder &_fbb,
    joescan::schema::server::MessageType type = joescan::schema::server::MessageType_NONE,
    joescan::schema::server::MessageData data_type = joescan::schema::server::MessageData_NONE,
    flatbuffers::Offset<void> data = 0) {
  MessageServerBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

flatbuffers::Offset<MessageServer> CreateMessageServer(flatbuffers::FlatBufferBuilder &_fbb, const MessageServerT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ImageDataT *ImageData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ImageDataT>(new ImageDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ImageData::UnPackTo(ImageDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = timestamp_ns(); _o->timestamp_ns = _e; }
  { auto _e = camera_port(); _o->camera_port = _e; }
  { auto _e = laser_port(); _o->laser_port = _e; }
  { auto _e = camera_exposure_ns(); _o->camera_exposure_ns = _e; }
  { auto _e = laser_on_time_ns(); _o->laser_on_time_ns = _e; }
  { auto _e = height(); _o->height = _e; }
  { auto _e = width(); _o->width = _e; }
  { auto _e = pixels(); if (_e) { _o->pixels.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->pixels.begin()); } }
  { auto _e = peaks(); if (_e) { _o->peaks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->peaks[_i] = *_e->Get(_i); } } }
  { auto _e = encoders(); if (_e) { _o->encoders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->encoders[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ImageData> ImageData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ImageDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateImageData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ImageData> CreateImageData(flatbuffers::FlatBufferBuilder &_fbb, const ImageDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ImageDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _timestamp_ns = _o->timestamp_ns;
  auto _camera_port = _o->camera_port;
  auto _laser_port = _o->laser_port;
  auto _camera_exposure_ns = _o->camera_exposure_ns;
  auto _laser_on_time_ns = _o->laser_on_time_ns;
  auto _height = _o->height;
  auto _width = _o->width;
  auto _pixels = _o->pixels.size() ? _fbb.CreateVector(_o->pixels) : 0;
  auto _peaks = _o->peaks.size() ? _fbb.CreateVectorOfStructs(_o->peaks) : 0;
  auto _encoders = _o->encoders.size() ? _fbb.CreateVector(_o->encoders) : 0;
  return joescan::schema::server::CreateImageData(
      _fbb,
      _timestamp_ns,
      _camera_port,
      _laser_port,
      _camera_exposure_ns,
      _laser_on_time_ns,
      _height,
      _width,
      _pixels,
      _peaks,
      _encoders);
}

inline ProfileDataT *ProfileData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProfileDataT>(new ProfileDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProfileData::UnPackTo(ProfileDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = timestamp_ns(); _o->timestamp_ns = _e; }
  { auto _e = camera_port(); _o->camera_port = _e; }
  { auto _e = laser_port(); _o->laser_port = _e; }
  { auto _e = camera_exposure_ns(); _o->camera_exposure_ns = _e; }
  { auto _e = laser_on_time_ns(); _o->laser_on_time_ns = _e; }
  { auto _e = valid_points(); _o->valid_points = _e; }
  { auto _e = points(); if (_e) { _o->points.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->points[_i] = *_e->Get(_i); } } }
  { auto _e = encoders(); if (_e) { _o->encoders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->encoders[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<ProfileData> ProfileData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProfileDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProfileData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProfileData> CreateProfileData(flatbuffers::FlatBufferBuilder &_fbb, const ProfileDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProfileDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _timestamp_ns = _o->timestamp_ns;
  auto _camera_port = _o->camera_port;
  auto _laser_port = _o->laser_port;
  auto _camera_exposure_ns = _o->camera_exposure_ns;
  auto _laser_on_time_ns = _o->laser_on_time_ns;
  auto _valid_points = _o->valid_points;
  auto _points = _o->points.size() ? _fbb.CreateVectorOfStructs(_o->points) : 0;
  auto _encoders = _o->encoders.size() ? _fbb.CreateVector(_o->encoders) : 0;
  return joescan::schema::server::CreateProfileData(
      _fbb,
      _timestamp_ns,
      _camera_port,
      _laser_port,
      _camera_exposure_ns,
      _laser_on_time_ns,
      _valid_points,
      _points,
      _encoders);
}

inline CameraDataT *CameraData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CameraDataT>(new CameraDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CameraData::UnPackTo(CameraDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = port(); _o->port = _e; }
  { auto _e = pixels_in_window(); _o->pixels_in_window = _e; }
  { auto _e = temperature(); _o->temperature = _e; }
}

inline flatbuffers::Offset<CameraData> CameraData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CameraDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCameraData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CameraData> CreateCameraData(flatbuffers::FlatBufferBuilder &_fbb, const CameraDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CameraDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _port = _o->port;
  auto _pixels_in_window = _o->pixels_in_window;
  auto _temperature = _o->temperature;
  return joescan::schema::server::CreateCameraData(
      _fbb,
      _port,
      _pixels_in_window,
      _temperature);
}

inline StatusDataT *StatusData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StatusDataT>(new StatusDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StatusData::UnPackTo(StatusDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = min_scan_period_ns(); _o->min_scan_period_ns = _e; }
  { auto _e = global_time_ns(); _o->global_time_ns = _e; }
  { auto _e = num_packets_sent(); _o->num_packets_sent = _e; }
  { auto _e = num_profiles_sent(); _o->num_profiles_sent = _e; }
  { auto _e = encoders(); if (_e) { _o->encoders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->encoders[_i] = _e->Get(_i); } } }
  { auto _e = camera_data(); if (_e) { _o->camera_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->camera_data[_i] = std::unique_ptr<joescan::schema::server::CameraDataT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<StatusData> StatusData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatusDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatusData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StatusData> CreateStatusData(flatbuffers::FlatBufferBuilder &_fbb, const StatusDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StatusDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _min_scan_period_ns = _o->min_scan_period_ns;
  auto _global_time_ns = _o->global_time_ns;
  auto _num_packets_sent = _o->num_packets_sent;
  auto _num_profiles_sent = _o->num_profiles_sent;
  auto _encoders = _o->encoders.size() ? _fbb.CreateVector(_o->encoders) : 0;
  auto _camera_data = _o->camera_data.size() ? _fbb.CreateVector<flatbuffers::Offset<joescan::schema::server::CameraData>> (_o->camera_data.size(), [](size_t i, _VectorArgs *__va) { return CreateCameraData(*__va->__fbb, __va->__o->camera_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  return joescan::schema::server::CreateStatusData(
      _fbb,
      _min_scan_period_ns,
      _global_time_ns,
      _num_packets_sent,
      _num_profiles_sent,
      _encoders,
      _camera_data);
}

inline MappleDataT *MappleData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MappleDataT>(new MappleDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MappleData::UnPackTo(MappleDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x_values(); if (_e) { _o->x_values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->x_values[_i] = _e->Get(_i); } } }
  { auto _e = y_values(); if (_e) { _o->y_values.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->y_values[_i] = _e->Get(_i); } } }
  { auto _e = window_bitmap(); if (_e) { _o->window_bitmap.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->window_bitmap.begin()); } }
}

inline flatbuffers::Offset<MappleData> MappleData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MappleDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMappleData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MappleData> CreateMappleData(flatbuffers::FlatBufferBuilder &_fbb, const MappleDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MappleDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x_values = _o->x_values.size() ? _fbb.CreateVector(_o->x_values) : 0;
  auto _y_values = _o->y_values.size() ? _fbb.CreateVector(_o->y_values) : 0;
  auto _window_bitmap = _o->window_bitmap.size() ? _fbb.CreateVector(_o->window_bitmap) : 0;
  return joescan::schema::server::CreateMappleData(
      _fbb,
      _x_values,
      _y_values,
      _window_bitmap);
}

inline MessageServerT *MessageServer::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MessageServerT>(new MessageServerT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MessageServer::UnPackTo(MessageServerT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = joescan::schema::server::MessageDataUnion::UnPack(_e, data_type(), _resolver); }
}

inline flatbuffers::Offset<MessageServer> MessageServer::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageServerT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageServer(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageServer> CreateMessageServer(flatbuffers::FlatBufferBuilder &_fbb, const MessageServerT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageServerT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return joescan::schema::server::CreateMessageServer(
      _fbb,
      _type,
      _data_type,
      _data);
}

inline bool VerifyMessageData(flatbuffers::Verifier &verifier, const void *obj, MessageData type) {
  switch (type) {
    case MessageData_NONE: {
      return true;
    }
    case MessageData_ImageData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::ImageData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_StatusData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::StatusData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_MappleData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::MappleData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_ProfileData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::ProfileData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageData(
        verifier,  values->Get(i), types->GetEnum<MessageData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageDataUnion::UnPack(const void *obj, MessageData type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case MessageData_ImageData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::ImageData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_StatusData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::StatusData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_MappleData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::MappleData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_ProfileData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::ProfileData *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageDataUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case MessageData_ImageData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::ImageDataT *>(value);
      return CreateImageData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_StatusData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::StatusDataT *>(value);
      return CreateStatusData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_MappleData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::MappleDataT *>(value);
      return CreateMappleData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_ProfileData: {
      auto ptr = reinterpret_cast<const joescan::schema::server::ProfileDataT *>(value);
      return CreateProfileData(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageDataUnion::MessageDataUnion(const MessageDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case MessageData_ImageData: {
      FLATBUFFERS_ASSERT(false);  // joescan::schema::server::ImageDataT not copyable.
      break;
    }
    case MessageData_StatusData: {
      FLATBUFFERS_ASSERT(false);  // joescan::schema::server::StatusDataT not copyable.
      break;
    }
    case MessageData_MappleData: {
      value = new joescan::schema::server::MappleDataT(*reinterpret_cast<joescan::schema::server::MappleDataT *>(u.value));
      break;
    }
    case MessageData_ProfileData: {
      FLATBUFFERS_ASSERT(false);  // joescan::schema::server::ProfileDataT not copyable.
      break;
    }
    default:
      break;
  }
}

inline void MessageDataUnion::Reset() {
  switch (type) {
    case MessageData_ImageData: {
      auto ptr = reinterpret_cast<joescan::schema::server::ImageDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_StatusData: {
      auto ptr = reinterpret_cast<joescan::schema::server::StatusDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_MappleData: {
      auto ptr = reinterpret_cast<joescan::schema::server::MappleDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_ProfileData: {
      auto ptr = reinterpret_cast<joescan::schema::server::ProfileDataT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MessageData_NONE;
}

inline const joescan::schema::server::MessageServer *GetMessageServer(const void *buf) {
  return flatbuffers::GetRoot<joescan::schema::server::MessageServer>(buf);
}

inline const joescan::schema::server::MessageServer *GetSizePrefixedMessageServer(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<joescan::schema::server::MessageServer>(buf);
}

inline bool VerifyMessageServerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<joescan::schema::server::MessageServer>(nullptr);
}

inline bool VerifySizePrefixedMessageServerBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<joescan::schema::server::MessageServer>(nullptr);
}

inline void FinishMessageServerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<joescan::schema::server::MessageServer> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageServerBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<joescan::schema::server::MessageServer> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<joescan::schema::server::MessageServerT> UnPackMessageServer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<joescan::schema::server::MessageServerT>(GetMessageServer(buf)->UnPack(res));
}

inline std::unique_ptr<joescan::schema::server::MessageServerT> UnPackSizePrefixedMessageServer(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<joescan::schema::server::MessageServerT>(GetSizePrefixedMessageServer(buf)->UnPack(res));
}

}  // namespace server
}  // namespace schema
}  // namespace joescan

#endif  // FLATBUFFERS_GENERATED_MESSAGESERVER_JOESCAN_SCHEMA_SERVER_H_
