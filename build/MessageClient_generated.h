// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MESSAGECLIENT_JOESCAN_SCHEMA_CLIENT_H_
#define FLATBUFFERS_GENERATED_MESSAGECLIENT_JOESCAN_SCHEMA_CLIENT_H_

#include "flatbuffers/flatbuffers.h"

namespace joescan {
namespace schema {
namespace client {

struct ConnectData;
struct ConnectDataBuilder;
struct ConnectDataT;

struct CameraLaserConfiguration;
struct CameraLaserConfigurationBuilder;
struct CameraLaserConfigurationT;

struct ScanConfigurationData;
struct ScanConfigurationDataBuilder;
struct ScanConfigurationDataT;

struct ImageRequestData;
struct ImageRequestDataBuilder;
struct ImageRequestDataT;

struct ProfileRequestData;
struct ProfileRequestDataBuilder;
struct ProfileRequestDataT;

struct MappleRequestData;
struct MappleRequestDataBuilder;
struct MappleRequestDataT;

struct Constraint;
struct ConstraintBuilder;
struct ConstraintT;

struct WindowConfigurationData;
struct WindowConfigurationDataBuilder;
struct WindowConfigurationDataT;

struct ExclusionMaskData;
struct ExclusionMaskDataBuilder;
struct ExclusionMaskDataT;

struct BrightnessCorrectionData;
struct BrightnessCorrectionDataBuilder;
struct BrightnessCorrectionDataT;

struct ScanStartData;
struct ScanStartDataBuilder;
struct ScanStartDataT;

struct MessageClient;
struct MessageClientBuilder;
struct MessageClientT;

enum MessageType : uint16_t {
  MessageType_NONE = 0,
  MessageType_CONNECT = 1,
  MessageType_DISCONNECT = 2,
  MessageType_SCAN_START = 3,
  MessageType_SCAN_STOP = 4,
  MessageType_WINDOW_CONFIGURATION = 5,
  MessageType_SCAN_CONFIGURATION = 6,
  MessageType_IMAGE_REQUEST = 7,
  MessageType_STATUS_REQUEST = 8,
  MessageType_KEEP_ALIVE = 9,
  MessageType_MAPPLE_REQUEST = 10,
  MessageType_PROFILE_REQUEST = 11,
  MessageType_EXCLUSION_MASK = 12,
  MessageType_BRIGHTNESS_CORRECTION = 13,
  MessageType_MIN = MessageType_NONE,
  MessageType_MAX = MessageType_BRIGHTNESS_CORRECTION
};

inline const MessageType (&EnumValuesMessageType())[14] {
  static const MessageType values[] = {
    MessageType_NONE,
    MessageType_CONNECT,
    MessageType_DISCONNECT,
    MessageType_SCAN_START,
    MessageType_SCAN_STOP,
    MessageType_WINDOW_CONFIGURATION,
    MessageType_SCAN_CONFIGURATION,
    MessageType_IMAGE_REQUEST,
    MessageType_STATUS_REQUEST,
    MessageType_KEEP_ALIVE,
    MessageType_MAPPLE_REQUEST,
    MessageType_PROFILE_REQUEST,
    MessageType_EXCLUSION_MASK,
    MessageType_BRIGHTNESS_CORRECTION
  };
  return values;
}

inline const char * const *EnumNamesMessageType() {
  static const char * const names[15] = {
    "NONE",
    "CONNECT",
    "DISCONNECT",
    "SCAN_START",
    "SCAN_STOP",
    "WINDOW_CONFIGURATION",
    "SCAN_CONFIGURATION",
    "IMAGE_REQUEST",
    "STATUS_REQUEST",
    "KEEP_ALIVE",
    "MAPPLE_REQUEST",
    "PROFILE_REQUEST",
    "EXCLUSION_MASK",
    "BRIGHTNESS_CORRECTION",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageType(MessageType e) {
  if (flatbuffers::IsOutRange(e, MessageType_NONE, MessageType_BRIGHTNESS_CORRECTION)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageType()[index];
}

enum ConnectionType : uint16_t {
  ConnectionType_NORMAL = 0,
  ConnectionType_MAPPLER = 1,
  ConnectionType_MIN = ConnectionType_NORMAL,
  ConnectionType_MAX = ConnectionType_MAPPLER
};

inline const ConnectionType (&EnumValuesConnectionType())[2] {
  static const ConnectionType values[] = {
    ConnectionType_NORMAL,
    ConnectionType_MAPPLER
  };
  return values;
}

inline const char * const *EnumNamesConnectionType() {
  static const char * const names[3] = {
    "NORMAL",
    "MAPPLER",
    nullptr
  };
  return names;
}

inline const char *EnumNameConnectionType(ConnectionType e) {
  if (flatbuffers::IsOutRange(e, ConnectionType_NORMAL, ConnectionType_MAPPLER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConnectionType()[index];
}

enum CameraOrientation : uint16_t {
  CameraOrientation_UPSTREAM = 0,
  CameraOrientation_DOWNSTREAM = 1,
  CameraOrientation_MIN = CameraOrientation_UPSTREAM,
  CameraOrientation_MAX = CameraOrientation_DOWNSTREAM
};

inline const CameraOrientation (&EnumValuesCameraOrientation())[2] {
  static const CameraOrientation values[] = {
    CameraOrientation_UPSTREAM,
    CameraOrientation_DOWNSTREAM
  };
  return values;
}

inline const char * const *EnumNamesCameraOrientation() {
  static const char * const names[3] = {
    "UPSTREAM",
    "DOWNSTREAM",
    nullptr
  };
  return names;
}

inline const char *EnumNameCameraOrientation(CameraOrientation e) {
  if (flatbuffers::IsOutRange(e, CameraOrientation_UPSTREAM, CameraOrientation_DOWNSTREAM)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCameraOrientation()[index];
}

enum ImageDataType : uint16_t {
  ImageDataType_MERGED_MASK_IMAGE = 0,
  ImageDataType_RAW_IMAGE = 1,
  ImageDataType_MIN = ImageDataType_MERGED_MASK_IMAGE,
  ImageDataType_MAX = ImageDataType_RAW_IMAGE
};

inline const ImageDataType (&EnumValuesImageDataType())[2] {
  static const ImageDataType values[] = {
    ImageDataType_MERGED_MASK_IMAGE,
    ImageDataType_RAW_IMAGE
  };
  return values;
}

inline const char * const *EnumNamesImageDataType() {
  static const char * const names[3] = {
    "MERGED_MASK_IMAGE",
    "RAW_IMAGE",
    nullptr
  };
  return names;
}

inline const char *EnumNameImageDataType(ImageDataType e) {
  if (flatbuffers::IsOutRange(e, ImageDataType_MERGED_MASK_IMAGE, ImageDataType_RAW_IMAGE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesImageDataType()[index];
}

enum MessageData : uint8_t {
  MessageData_NONE = 0,
  MessageData_ConnectData = 1,
  MessageData_ScanConfigurationData = 2,
  MessageData_WindowConfigurationData = 3,
  MessageData_ImageRequestData = 4,
  MessageData_MappleRequestData = 5,
  MessageData_ProfileRequestData = 6,
  MessageData_ExclusionMaskData = 7,
  MessageData_BrightnessCorrectionData = 8,
  MessageData_ScanStartData = 9,
  MessageData_MIN = MessageData_NONE,
  MessageData_MAX = MessageData_ScanStartData
};

inline const MessageData (&EnumValuesMessageData())[10] {
  static const MessageData values[] = {
    MessageData_NONE,
    MessageData_ConnectData,
    MessageData_ScanConfigurationData,
    MessageData_WindowConfigurationData,
    MessageData_ImageRequestData,
    MessageData_MappleRequestData,
    MessageData_ProfileRequestData,
    MessageData_ExclusionMaskData,
    MessageData_BrightnessCorrectionData,
    MessageData_ScanStartData
  };
  return values;
}

inline const char * const *EnumNamesMessageData() {
  static const char * const names[11] = {
    "NONE",
    "ConnectData",
    "ScanConfigurationData",
    "WindowConfigurationData",
    "ImageRequestData",
    "MappleRequestData",
    "ProfileRequestData",
    "ExclusionMaskData",
    "BrightnessCorrectionData",
    "ScanStartData",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageData(MessageData e) {
  if (flatbuffers::IsOutRange(e, MessageData_NONE, MessageData_ScanStartData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMessageData()[index];
}

template<typename T> struct MessageDataTraits {
  static const MessageData enum_value = MessageData_NONE;
};

template<> struct MessageDataTraits<joescan::schema::client::ConnectData> {
  static const MessageData enum_value = MessageData_ConnectData;
};

template<> struct MessageDataTraits<joescan::schema::client::ScanConfigurationData> {
  static const MessageData enum_value = MessageData_ScanConfigurationData;
};

template<> struct MessageDataTraits<joescan::schema::client::WindowConfigurationData> {
  static const MessageData enum_value = MessageData_WindowConfigurationData;
};

template<> struct MessageDataTraits<joescan::schema::client::ImageRequestData> {
  static const MessageData enum_value = MessageData_ImageRequestData;
};

template<> struct MessageDataTraits<joescan::schema::client::MappleRequestData> {
  static const MessageData enum_value = MessageData_MappleRequestData;
};

template<> struct MessageDataTraits<joescan::schema::client::ProfileRequestData> {
  static const MessageData enum_value = MessageData_ProfileRequestData;
};

template<> struct MessageDataTraits<joescan::schema::client::ExclusionMaskData> {
  static const MessageData enum_value = MessageData_ExclusionMaskData;
};

template<> struct MessageDataTraits<joescan::schema::client::BrightnessCorrectionData> {
  static const MessageData enum_value = MessageData_BrightnessCorrectionData;
};

template<> struct MessageDataTraits<joescan::schema::client::ScanStartData> {
  static const MessageData enum_value = MessageData_ScanStartData;
};

struct MessageDataUnion {
  MessageData type;
  void *value;

  MessageDataUnion() : type(MessageData_NONE), value(nullptr) {}
  MessageDataUnion(MessageDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(MessageData_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  MessageDataUnion(const MessageDataUnion &);
  MessageDataUnion &operator=(const MessageDataUnion &u)
    { MessageDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  MessageDataUnion &operator=(MessageDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~MessageDataUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = MessageDataTraits<typename RT::TableType>::enum_value;
    if (type != MessageData_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, MessageData type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  joescan::schema::client::ConnectDataT *AsConnectData() {
    return type == MessageData_ConnectData ?
      reinterpret_cast<joescan::schema::client::ConnectDataT *>(value) : nullptr;
  }
  const joescan::schema::client::ConnectDataT *AsConnectData() const {
    return type == MessageData_ConnectData ?
      reinterpret_cast<const joescan::schema::client::ConnectDataT *>(value) : nullptr;
  }
  joescan::schema::client::ScanConfigurationDataT *AsScanConfigurationData() {
    return type == MessageData_ScanConfigurationData ?
      reinterpret_cast<joescan::schema::client::ScanConfigurationDataT *>(value) : nullptr;
  }
  const joescan::schema::client::ScanConfigurationDataT *AsScanConfigurationData() const {
    return type == MessageData_ScanConfigurationData ?
      reinterpret_cast<const joescan::schema::client::ScanConfigurationDataT *>(value) : nullptr;
  }
  joescan::schema::client::WindowConfigurationDataT *AsWindowConfigurationData() {
    return type == MessageData_WindowConfigurationData ?
      reinterpret_cast<joescan::schema::client::WindowConfigurationDataT *>(value) : nullptr;
  }
  const joescan::schema::client::WindowConfigurationDataT *AsWindowConfigurationData() const {
    return type == MessageData_WindowConfigurationData ?
      reinterpret_cast<const joescan::schema::client::WindowConfigurationDataT *>(value) : nullptr;
  }
  joescan::schema::client::ImageRequestDataT *AsImageRequestData() {
    return type == MessageData_ImageRequestData ?
      reinterpret_cast<joescan::schema::client::ImageRequestDataT *>(value) : nullptr;
  }
  const joescan::schema::client::ImageRequestDataT *AsImageRequestData() const {
    return type == MessageData_ImageRequestData ?
      reinterpret_cast<const joescan::schema::client::ImageRequestDataT *>(value) : nullptr;
  }
  joescan::schema::client::MappleRequestDataT *AsMappleRequestData() {
    return type == MessageData_MappleRequestData ?
      reinterpret_cast<joescan::schema::client::MappleRequestDataT *>(value) : nullptr;
  }
  const joescan::schema::client::MappleRequestDataT *AsMappleRequestData() const {
    return type == MessageData_MappleRequestData ?
      reinterpret_cast<const joescan::schema::client::MappleRequestDataT *>(value) : nullptr;
  }
  joescan::schema::client::ProfileRequestDataT *AsProfileRequestData() {
    return type == MessageData_ProfileRequestData ?
      reinterpret_cast<joescan::schema::client::ProfileRequestDataT *>(value) : nullptr;
  }
  const joescan::schema::client::ProfileRequestDataT *AsProfileRequestData() const {
    return type == MessageData_ProfileRequestData ?
      reinterpret_cast<const joescan::schema::client::ProfileRequestDataT *>(value) : nullptr;
  }
  joescan::schema::client::ExclusionMaskDataT *AsExclusionMaskData() {
    return type == MessageData_ExclusionMaskData ?
      reinterpret_cast<joescan::schema::client::ExclusionMaskDataT *>(value) : nullptr;
  }
  const joescan::schema::client::ExclusionMaskDataT *AsExclusionMaskData() const {
    return type == MessageData_ExclusionMaskData ?
      reinterpret_cast<const joescan::schema::client::ExclusionMaskDataT *>(value) : nullptr;
  }
  joescan::schema::client::BrightnessCorrectionDataT *AsBrightnessCorrectionData() {
    return type == MessageData_BrightnessCorrectionData ?
      reinterpret_cast<joescan::schema::client::BrightnessCorrectionDataT *>(value) : nullptr;
  }
  const joescan::schema::client::BrightnessCorrectionDataT *AsBrightnessCorrectionData() const {
    return type == MessageData_BrightnessCorrectionData ?
      reinterpret_cast<const joescan::schema::client::BrightnessCorrectionDataT *>(value) : nullptr;
  }
  joescan::schema::client::ScanStartDataT *AsScanStartData() {
    return type == MessageData_ScanStartData ?
      reinterpret_cast<joescan::schema::client::ScanStartDataT *>(value) : nullptr;
  }
  const joescan::schema::client::ScanStartDataT *AsScanStartData() const {
    return type == MessageData_ScanStartData ?
      reinterpret_cast<const joescan::schema::client::ScanStartDataT *>(value) : nullptr;
  }
};

bool VerifyMessageData(flatbuffers::Verifier &verifier, const void *obj, MessageData type);
bool VerifyMessageDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ConnectDataT : public flatbuffers::NativeTable {
  typedef ConnectData TableType;
  uint32_t scan_head_serial = 0;
  uint32_t scan_head_id = 0;
  joescan::schema::client::ConnectionType connection_type = joescan::schema::client::ConnectionType_NORMAL;
};

struct ConnectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectDataT NativeTableType;
  typedef ConnectDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCAN_HEAD_SERIAL = 4,
    VT_SCAN_HEAD_ID = 6,
    VT_CONNECTION_TYPE = 8
  };
  uint32_t scan_head_serial() const {
    return GetField<uint32_t>(VT_SCAN_HEAD_SERIAL, 0);
  }
  uint32_t scan_head_id() const {
    return GetField<uint32_t>(VT_SCAN_HEAD_ID, 0);
  }
  joescan::schema::client::ConnectionType connection_type() const {
    return static_cast<joescan::schema::client::ConnectionType>(GetField<uint16_t>(VT_CONNECTION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SCAN_HEAD_SERIAL) &&
           VerifyField<uint32_t>(verifier, VT_SCAN_HEAD_ID) &&
           VerifyField<uint16_t>(verifier, VT_CONNECTION_TYPE) &&
           verifier.EndTable();
  }
  ConnectDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConnectDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConnectData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConnectDataBuilder {
  typedef ConnectData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scan_head_serial(uint32_t scan_head_serial) {
    fbb_.AddElement<uint32_t>(ConnectData::VT_SCAN_HEAD_SERIAL, scan_head_serial, 0);
  }
  void add_scan_head_id(uint32_t scan_head_id) {
    fbb_.AddElement<uint32_t>(ConnectData::VT_SCAN_HEAD_ID, scan_head_id, 0);
  }
  void add_connection_type(joescan::schema::client::ConnectionType connection_type) {
    fbb_.AddElement<uint16_t>(ConnectData::VT_CONNECTION_TYPE, static_cast<uint16_t>(connection_type), 0);
  }
  explicit ConnectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConnectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectData> CreateConnectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t scan_head_serial = 0,
    uint32_t scan_head_id = 0,
    joescan::schema::client::ConnectionType connection_type = joescan::schema::client::ConnectionType_NORMAL) {
  ConnectDataBuilder builder_(_fbb);
  builder_.add_scan_head_id(scan_head_id);
  builder_.add_scan_head_serial(scan_head_serial);
  builder_.add_connection_type(connection_type);
  return builder_.Finish();
}

flatbuffers::Offset<ConnectData> CreateConnectData(flatbuffers::FlatBufferBuilder &_fbb, const ConnectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CameraLaserConfigurationT : public flatbuffers::NativeTable {
  typedef CameraLaserConfiguration TableType;
  uint32_t camera_port = 0;
  uint32_t laser_port = 0;
  uint32_t laser_on_time_min_ns = 0;
  uint32_t laser_on_time_def_ns = 0;
  uint32_t laser_on_time_max_ns = 0;
  uint32_t scan_end_offset_ns = 0;
  joescan::schema::client::CameraOrientation camera_orientation = joescan::schema::client::CameraOrientation_UPSTREAM;
};

struct CameraLaserConfiguration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CameraLaserConfigurationT NativeTableType;
  typedef CameraLaserConfigurationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAMERA_PORT = 4,
    VT_LASER_PORT = 6,
    VT_LASER_ON_TIME_MIN_NS = 8,
    VT_LASER_ON_TIME_DEF_NS = 10,
    VT_LASER_ON_TIME_MAX_NS = 12,
    VT_SCAN_END_OFFSET_NS = 14,
    VT_CAMERA_ORIENTATION = 16
  };
  uint32_t camera_port() const {
    return GetField<uint32_t>(VT_CAMERA_PORT, 0);
  }
  uint32_t laser_port() const {
    return GetField<uint32_t>(VT_LASER_PORT, 0);
  }
  uint32_t laser_on_time_min_ns() const {
    return GetField<uint32_t>(VT_LASER_ON_TIME_MIN_NS, 0);
  }
  uint32_t laser_on_time_def_ns() const {
    return GetField<uint32_t>(VT_LASER_ON_TIME_DEF_NS, 0);
  }
  uint32_t laser_on_time_max_ns() const {
    return GetField<uint32_t>(VT_LASER_ON_TIME_MAX_NS, 0);
  }
  uint32_t scan_end_offset_ns() const {
    return GetField<uint32_t>(VT_SCAN_END_OFFSET_NS, 0);
  }
  joescan::schema::client::CameraOrientation camera_orientation() const {
    return static_cast<joescan::schema::client::CameraOrientation>(GetField<uint16_t>(VT_CAMERA_ORIENTATION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_ON_TIME_MIN_NS) &&
           VerifyField<uint32_t>(verifier, VT_LASER_ON_TIME_DEF_NS) &&
           VerifyField<uint32_t>(verifier, VT_LASER_ON_TIME_MAX_NS) &&
           VerifyField<uint32_t>(verifier, VT_SCAN_END_OFFSET_NS) &&
           VerifyField<uint16_t>(verifier, VT_CAMERA_ORIENTATION) &&
           verifier.EndTable();
  }
  CameraLaserConfigurationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CameraLaserConfigurationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CameraLaserConfiguration> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CameraLaserConfigurationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CameraLaserConfigurationBuilder {
  typedef CameraLaserConfiguration Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_camera_port(uint32_t camera_port) {
    fbb_.AddElement<uint32_t>(CameraLaserConfiguration::VT_CAMERA_PORT, camera_port, 0);
  }
  void add_laser_port(uint32_t laser_port) {
    fbb_.AddElement<uint32_t>(CameraLaserConfiguration::VT_LASER_PORT, laser_port, 0);
  }
  void add_laser_on_time_min_ns(uint32_t laser_on_time_min_ns) {
    fbb_.AddElement<uint32_t>(CameraLaserConfiguration::VT_LASER_ON_TIME_MIN_NS, laser_on_time_min_ns, 0);
  }
  void add_laser_on_time_def_ns(uint32_t laser_on_time_def_ns) {
    fbb_.AddElement<uint32_t>(CameraLaserConfiguration::VT_LASER_ON_TIME_DEF_NS, laser_on_time_def_ns, 0);
  }
  void add_laser_on_time_max_ns(uint32_t laser_on_time_max_ns) {
    fbb_.AddElement<uint32_t>(CameraLaserConfiguration::VT_LASER_ON_TIME_MAX_NS, laser_on_time_max_ns, 0);
  }
  void add_scan_end_offset_ns(uint32_t scan_end_offset_ns) {
    fbb_.AddElement<uint32_t>(CameraLaserConfiguration::VT_SCAN_END_OFFSET_NS, scan_end_offset_ns, 0);
  }
  void add_camera_orientation(joescan::schema::client::CameraOrientation camera_orientation) {
    fbb_.AddElement<uint16_t>(CameraLaserConfiguration::VT_CAMERA_ORIENTATION, static_cast<uint16_t>(camera_orientation), 0);
  }
  explicit CameraLaserConfigurationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CameraLaserConfiguration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CameraLaserConfiguration>(end);
    return o;
  }
};

inline flatbuffers::Offset<CameraLaserConfiguration> CreateCameraLaserConfiguration(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    uint32_t laser_on_time_min_ns = 0,
    uint32_t laser_on_time_def_ns = 0,
    uint32_t laser_on_time_max_ns = 0,
    uint32_t scan_end_offset_ns = 0,
    joescan::schema::client::CameraOrientation camera_orientation = joescan::schema::client::CameraOrientation_UPSTREAM) {
  CameraLaserConfigurationBuilder builder_(_fbb);
  builder_.add_scan_end_offset_ns(scan_end_offset_ns);
  builder_.add_laser_on_time_max_ns(laser_on_time_max_ns);
  builder_.add_laser_on_time_def_ns(laser_on_time_def_ns);
  builder_.add_laser_on_time_min_ns(laser_on_time_min_ns);
  builder_.add_laser_port(laser_port);
  builder_.add_camera_port(camera_port);
  builder_.add_camera_orientation(camera_orientation);
  return builder_.Finish();
}

flatbuffers::Offset<CameraLaserConfiguration> CreateCameraLaserConfiguration(flatbuffers::FlatBufferBuilder &_fbb, const CameraLaserConfigurationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScanConfigurationDataT : public flatbuffers::NativeTable {
  typedef ScanConfigurationData TableType;
  uint32_t data_type_mask = 0;
  uint32_t data_stride = 0;
  uint32_t scan_period_ns = 0;
  uint32_t laser_detection_threshold = 0;
  uint32_t saturation_threshold = 0;
  uint32_t saturation_percent = 0;
  std::vector<std::unique_ptr<joescan::schema::client::CameraLaserConfigurationT>> camera_laser_configurations{};
};

struct ScanConfigurationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScanConfigurationDataT NativeTableType;
  typedef ScanConfigurationDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE_MASK = 6,
    VT_DATA_STRIDE = 8,
    VT_SCAN_PERIOD_NS = 10,
    VT_LASER_DETECTION_THRESHOLD = 12,
    VT_SATURATION_THRESHOLD = 14,
    VT_SATURATION_PERCENT = 16,
    VT_CAMERA_LASER_CONFIGURATIONS = 18
  };
  uint32_t data_type_mask() const {
    return GetField<uint32_t>(VT_DATA_TYPE_MASK, 0);
  }
  uint32_t data_stride() const {
    return GetField<uint32_t>(VT_DATA_STRIDE, 0);
  }
  uint32_t scan_period_ns() const {
    return GetField<uint32_t>(VT_SCAN_PERIOD_NS, 0);
  }
  uint32_t laser_detection_threshold() const {
    return GetField<uint32_t>(VT_LASER_DETECTION_THRESHOLD, 0);
  }
  uint32_t saturation_threshold() const {
    return GetField<uint32_t>(VT_SATURATION_THRESHOLD, 0);
  }
  uint32_t saturation_percent() const {
    return GetField<uint32_t>(VT_SATURATION_PERCENT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<joescan::schema::client::CameraLaserConfiguration>> *camera_laser_configurations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<joescan::schema::client::CameraLaserConfiguration>> *>(VT_CAMERA_LASER_CONFIGURATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DATA_TYPE_MASK) &&
           VerifyField<uint32_t>(verifier, VT_DATA_STRIDE) &&
           VerifyField<uint32_t>(verifier, VT_SCAN_PERIOD_NS) &&
           VerifyField<uint32_t>(verifier, VT_LASER_DETECTION_THRESHOLD) &&
           VerifyField<uint32_t>(verifier, VT_SATURATION_THRESHOLD) &&
           VerifyField<uint32_t>(verifier, VT_SATURATION_PERCENT) &&
           VerifyOffset(verifier, VT_CAMERA_LASER_CONFIGURATIONS) &&
           verifier.VerifyVector(camera_laser_configurations()) &&
           verifier.VerifyVectorOfTables(camera_laser_configurations()) &&
           verifier.EndTable();
  }
  ScanConfigurationDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScanConfigurationDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScanConfigurationData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScanConfigurationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScanConfigurationDataBuilder {
  typedef ScanConfigurationData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type_mask(uint32_t data_type_mask) {
    fbb_.AddElement<uint32_t>(ScanConfigurationData::VT_DATA_TYPE_MASK, data_type_mask, 0);
  }
  void add_data_stride(uint32_t data_stride) {
    fbb_.AddElement<uint32_t>(ScanConfigurationData::VT_DATA_STRIDE, data_stride, 0);
  }
  void add_scan_period_ns(uint32_t scan_period_ns) {
    fbb_.AddElement<uint32_t>(ScanConfigurationData::VT_SCAN_PERIOD_NS, scan_period_ns, 0);
  }
  void add_laser_detection_threshold(uint32_t laser_detection_threshold) {
    fbb_.AddElement<uint32_t>(ScanConfigurationData::VT_LASER_DETECTION_THRESHOLD, laser_detection_threshold, 0);
  }
  void add_saturation_threshold(uint32_t saturation_threshold) {
    fbb_.AddElement<uint32_t>(ScanConfigurationData::VT_SATURATION_THRESHOLD, saturation_threshold, 0);
  }
  void add_saturation_percent(uint32_t saturation_percent) {
    fbb_.AddElement<uint32_t>(ScanConfigurationData::VT_SATURATION_PERCENT, saturation_percent, 0);
  }
  void add_camera_laser_configurations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<joescan::schema::client::CameraLaserConfiguration>>> camera_laser_configurations) {
    fbb_.AddOffset(ScanConfigurationData::VT_CAMERA_LASER_CONFIGURATIONS, camera_laser_configurations);
  }
  explicit ScanConfigurationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScanConfigurationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScanConfigurationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScanConfigurationData> CreateScanConfigurationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t data_type_mask = 0,
    uint32_t data_stride = 0,
    uint32_t scan_period_ns = 0,
    uint32_t laser_detection_threshold = 0,
    uint32_t saturation_threshold = 0,
    uint32_t saturation_percent = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<joescan::schema::client::CameraLaserConfiguration>>> camera_laser_configurations = 0) {
  ScanConfigurationDataBuilder builder_(_fbb);
  builder_.add_camera_laser_configurations(camera_laser_configurations);
  builder_.add_saturation_percent(saturation_percent);
  builder_.add_saturation_threshold(saturation_threshold);
  builder_.add_laser_detection_threshold(laser_detection_threshold);
  builder_.add_scan_period_ns(scan_period_ns);
  builder_.add_data_stride(data_stride);
  builder_.add_data_type_mask(data_type_mask);
  return builder_.Finish();
}

inline flatbuffers::Offset<ScanConfigurationData> CreateScanConfigurationDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t data_type_mask = 0,
    uint32_t data_stride = 0,
    uint32_t scan_period_ns = 0,
    uint32_t laser_detection_threshold = 0,
    uint32_t saturation_threshold = 0,
    uint32_t saturation_percent = 0,
    const std::vector<flatbuffers::Offset<joescan::schema::client::CameraLaserConfiguration>> *camera_laser_configurations = nullptr) {
  auto camera_laser_configurations__ = camera_laser_configurations ? _fbb.CreateVector<flatbuffers::Offset<joescan::schema::client::CameraLaserConfiguration>>(*camera_laser_configurations) : 0;
  return joescan::schema::client::CreateScanConfigurationData(
      _fbb,
      data_type_mask,
      data_stride,
      scan_period_ns,
      laser_detection_threshold,
      saturation_threshold,
      saturation_percent,
      camera_laser_configurations__);
}

flatbuffers::Offset<ScanConfigurationData> CreateScanConfigurationData(flatbuffers::FlatBufferBuilder &_fbb, const ScanConfigurationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ImageRequestDataT : public flatbuffers::NativeTable {
  typedef ImageRequestData TableType;
  uint32_t camera_port = 0;
  uint32_t laser_port = 0;
  uint32_t camera_exposure_ns = 0;
  uint32_t laser_on_time_ns = 0;
  uint32_t laser_detection_threshold = 0;
  uint32_t saturation_threshold = 0;
  joescan::schema::client::ImageDataType image_data_type = joescan::schema::client::ImageDataType_MERGED_MASK_IMAGE;
};

struct ImageRequestData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ImageRequestDataT NativeTableType;
  typedef ImageRequestDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAMERA_PORT = 4,
    VT_LASER_PORT = 6,
    VT_CAMERA_EXPOSURE_NS = 8,
    VT_LASER_ON_TIME_NS = 10,
    VT_LASER_DETECTION_THRESHOLD = 12,
    VT_SATURATION_THRESHOLD = 14,
    VT_IMAGE_DATA_TYPE = 16
  };
  uint32_t camera_port() const {
    return GetField<uint32_t>(VT_CAMERA_PORT, 0);
  }
  uint32_t laser_port() const {
    return GetField<uint32_t>(VT_LASER_PORT, 0);
  }
  uint32_t camera_exposure_ns() const {
    return GetField<uint32_t>(VT_CAMERA_EXPOSURE_NS, 0);
  }
  uint32_t laser_on_time_ns() const {
    return GetField<uint32_t>(VT_LASER_ON_TIME_NS, 0);
  }
  uint32_t laser_detection_threshold() const {
    return GetField<uint32_t>(VT_LASER_DETECTION_THRESHOLD, 0);
  }
  uint32_t saturation_threshold() const {
    return GetField<uint32_t>(VT_SATURATION_THRESHOLD, 0);
  }
  joescan::schema::client::ImageDataType image_data_type() const {
    return static_cast<joescan::schema::client::ImageDataType>(GetField<uint16_t>(VT_IMAGE_DATA_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_PORT) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_EXPOSURE_NS) &&
           VerifyField<uint32_t>(verifier, VT_LASER_ON_TIME_NS) &&
           VerifyField<uint32_t>(verifier, VT_LASER_DETECTION_THRESHOLD) &&
           VerifyField<uint32_t>(verifier, VT_SATURATION_THRESHOLD) &&
           VerifyField<uint16_t>(verifier, VT_IMAGE_DATA_TYPE) &&
           verifier.EndTable();
  }
  ImageRequestDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ImageRequestDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ImageRequestData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ImageRequestDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ImageRequestDataBuilder {
  typedef ImageRequestData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_camera_port(uint32_t camera_port) {
    fbb_.AddElement<uint32_t>(ImageRequestData::VT_CAMERA_PORT, camera_port, 0);
  }
  void add_laser_port(uint32_t laser_port) {
    fbb_.AddElement<uint32_t>(ImageRequestData::VT_LASER_PORT, laser_port, 0);
  }
  void add_camera_exposure_ns(uint32_t camera_exposure_ns) {
    fbb_.AddElement<uint32_t>(ImageRequestData::VT_CAMERA_EXPOSURE_NS, camera_exposure_ns, 0);
  }
  void add_laser_on_time_ns(uint32_t laser_on_time_ns) {
    fbb_.AddElement<uint32_t>(ImageRequestData::VT_LASER_ON_TIME_NS, laser_on_time_ns, 0);
  }
  void add_laser_detection_threshold(uint32_t laser_detection_threshold) {
    fbb_.AddElement<uint32_t>(ImageRequestData::VT_LASER_DETECTION_THRESHOLD, laser_detection_threshold, 0);
  }
  void add_saturation_threshold(uint32_t saturation_threshold) {
    fbb_.AddElement<uint32_t>(ImageRequestData::VT_SATURATION_THRESHOLD, saturation_threshold, 0);
  }
  void add_image_data_type(joescan::schema::client::ImageDataType image_data_type) {
    fbb_.AddElement<uint16_t>(ImageRequestData::VT_IMAGE_DATA_TYPE, static_cast<uint16_t>(image_data_type), 0);
  }
  explicit ImageRequestDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ImageRequestData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ImageRequestData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ImageRequestData> CreateImageRequestData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    uint32_t camera_exposure_ns = 0,
    uint32_t laser_on_time_ns = 0,
    uint32_t laser_detection_threshold = 0,
    uint32_t saturation_threshold = 0,
    joescan::schema::client::ImageDataType image_data_type = joescan::schema::client::ImageDataType_MERGED_MASK_IMAGE) {
  ImageRequestDataBuilder builder_(_fbb);
  builder_.add_saturation_threshold(saturation_threshold);
  builder_.add_laser_detection_threshold(laser_detection_threshold);
  builder_.add_laser_on_time_ns(laser_on_time_ns);
  builder_.add_camera_exposure_ns(camera_exposure_ns);
  builder_.add_laser_port(laser_port);
  builder_.add_camera_port(camera_port);
  builder_.add_image_data_type(image_data_type);
  return builder_.Finish();
}

flatbuffers::Offset<ImageRequestData> CreateImageRequestData(flatbuffers::FlatBufferBuilder &_fbb, const ImageRequestDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProfileRequestDataT : public flatbuffers::NativeTable {
  typedef ProfileRequestData TableType;
  uint32_t camera_port = 0;
  uint32_t laser_port = 0;
  uint32_t camera_exposure_ns = 0;
  uint32_t laser_on_time_ns = 0;
  uint32_t laser_detection_threshold = 0;
  uint32_t saturation_threshold = 0;
  joescan::schema::client::CameraOrientation camera_orientation = joescan::schema::client::CameraOrientation_UPSTREAM;
};

struct ProfileRequestData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProfileRequestDataT NativeTableType;
  typedef ProfileRequestDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAMERA_PORT = 4,
    VT_LASER_PORT = 6,
    VT_CAMERA_EXPOSURE_NS = 8,
    VT_LASER_ON_TIME_NS = 10,
    VT_LASER_DETECTION_THRESHOLD = 12,
    VT_SATURATION_THRESHOLD = 14,
    VT_CAMERA_ORIENTATION = 16
  };
  uint32_t camera_port() const {
    return GetField<uint32_t>(VT_CAMERA_PORT, 0);
  }
  uint32_t laser_port() const {
    return GetField<uint32_t>(VT_LASER_PORT, 0);
  }
  uint32_t camera_exposure_ns() const {
    return GetField<uint32_t>(VT_CAMERA_EXPOSURE_NS, 0);
  }
  uint32_t laser_on_time_ns() const {
    return GetField<uint32_t>(VT_LASER_ON_TIME_NS, 0);
  }
  uint32_t laser_detection_threshold() const {
    return GetField<uint32_t>(VT_LASER_DETECTION_THRESHOLD, 0);
  }
  uint32_t saturation_threshold() const {
    return GetField<uint32_t>(VT_SATURATION_THRESHOLD, 0);
  }
  joescan::schema::client::CameraOrientation camera_orientation() const {
    return static_cast<joescan::schema::client::CameraOrientation>(GetField<uint16_t>(VT_CAMERA_ORIENTATION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_PORT) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_EXPOSURE_NS) &&
           VerifyField<uint32_t>(verifier, VT_LASER_ON_TIME_NS) &&
           VerifyField<uint32_t>(verifier, VT_LASER_DETECTION_THRESHOLD) &&
           VerifyField<uint32_t>(verifier, VT_SATURATION_THRESHOLD) &&
           VerifyField<uint16_t>(verifier, VT_CAMERA_ORIENTATION) &&
           verifier.EndTable();
  }
  ProfileRequestDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProfileRequestDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProfileRequestData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProfileRequestDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProfileRequestDataBuilder {
  typedef ProfileRequestData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_camera_port(uint32_t camera_port) {
    fbb_.AddElement<uint32_t>(ProfileRequestData::VT_CAMERA_PORT, camera_port, 0);
  }
  void add_laser_port(uint32_t laser_port) {
    fbb_.AddElement<uint32_t>(ProfileRequestData::VT_LASER_PORT, laser_port, 0);
  }
  void add_camera_exposure_ns(uint32_t camera_exposure_ns) {
    fbb_.AddElement<uint32_t>(ProfileRequestData::VT_CAMERA_EXPOSURE_NS, camera_exposure_ns, 0);
  }
  void add_laser_on_time_ns(uint32_t laser_on_time_ns) {
    fbb_.AddElement<uint32_t>(ProfileRequestData::VT_LASER_ON_TIME_NS, laser_on_time_ns, 0);
  }
  void add_laser_detection_threshold(uint32_t laser_detection_threshold) {
    fbb_.AddElement<uint32_t>(ProfileRequestData::VT_LASER_DETECTION_THRESHOLD, laser_detection_threshold, 0);
  }
  void add_saturation_threshold(uint32_t saturation_threshold) {
    fbb_.AddElement<uint32_t>(ProfileRequestData::VT_SATURATION_THRESHOLD, saturation_threshold, 0);
  }
  void add_camera_orientation(joescan::schema::client::CameraOrientation camera_orientation) {
    fbb_.AddElement<uint16_t>(ProfileRequestData::VT_CAMERA_ORIENTATION, static_cast<uint16_t>(camera_orientation), 0);
  }
  explicit ProfileRequestDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProfileRequestData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProfileRequestData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProfileRequestData> CreateProfileRequestData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    uint32_t camera_exposure_ns = 0,
    uint32_t laser_on_time_ns = 0,
    uint32_t laser_detection_threshold = 0,
    uint32_t saturation_threshold = 0,
    joescan::schema::client::CameraOrientation camera_orientation = joescan::schema::client::CameraOrientation_UPSTREAM) {
  ProfileRequestDataBuilder builder_(_fbb);
  builder_.add_saturation_threshold(saturation_threshold);
  builder_.add_laser_detection_threshold(laser_detection_threshold);
  builder_.add_laser_on_time_ns(laser_on_time_ns);
  builder_.add_camera_exposure_ns(camera_exposure_ns);
  builder_.add_laser_port(laser_port);
  builder_.add_camera_port(camera_port);
  builder_.add_camera_orientation(camera_orientation);
  return builder_.Finish();
}

flatbuffers::Offset<ProfileRequestData> CreateProfileRequestData(flatbuffers::FlatBufferBuilder &_fbb, const ProfileRequestDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MappleRequestDataT : public flatbuffers::NativeTable {
  typedef MappleRequestData TableType;
  uint32_t camera_port = 0;
  uint32_t laser_port = 0;
};

struct MappleRequestData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MappleRequestDataT NativeTableType;
  typedef MappleRequestDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAMERA_PORT = 4,
    VT_LASER_PORT = 6
  };
  uint32_t camera_port() const {
    return GetField<uint32_t>(VT_CAMERA_PORT, 0);
  }
  uint32_t laser_port() const {
    return GetField<uint32_t>(VT_LASER_PORT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_PORT) &&
           verifier.EndTable();
  }
  MappleRequestDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MappleRequestDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MappleRequestData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MappleRequestDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MappleRequestDataBuilder {
  typedef MappleRequestData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_camera_port(uint32_t camera_port) {
    fbb_.AddElement<uint32_t>(MappleRequestData::VT_CAMERA_PORT, camera_port, 0);
  }
  void add_laser_port(uint32_t laser_port) {
    fbb_.AddElement<uint32_t>(MappleRequestData::VT_LASER_PORT, laser_port, 0);
  }
  explicit MappleRequestDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MappleRequestData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MappleRequestData>(end);
    return o;
  }
};

inline flatbuffers::Offset<MappleRequestData> CreateMappleRequestData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0) {
  MappleRequestDataBuilder builder_(_fbb);
  builder_.add_laser_port(laser_port);
  builder_.add_camera_port(camera_port);
  return builder_.Finish();
}

flatbuffers::Offset<MappleRequestData> CreateMappleRequestData(flatbuffers::FlatBufferBuilder &_fbb, const MappleRequestDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConstraintT : public flatbuffers::NativeTable {
  typedef Constraint TableType;
  int64_t x0 = 0;
  int64_t y0 = 0;
  int64_t x1 = 0;
  int64_t y1 = 0;
};

struct Constraint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstraintT NativeTableType;
  typedef ConstraintBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X0 = 4,
    VT_Y0 = 6,
    VT_X1 = 8,
    VT_Y1 = 10
  };
  int64_t x0() const {
    return GetField<int64_t>(VT_X0, 0);
  }
  int64_t y0() const {
    return GetField<int64_t>(VT_Y0, 0);
  }
  int64_t x1() const {
    return GetField<int64_t>(VT_X1, 0);
  }
  int64_t y1() const {
    return GetField<int64_t>(VT_Y1, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_X0) &&
           VerifyField<int64_t>(verifier, VT_Y0) &&
           VerifyField<int64_t>(verifier, VT_X1) &&
           VerifyField<int64_t>(verifier, VT_Y1) &&
           verifier.EndTable();
  }
  ConstraintT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConstraintT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Constraint> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConstraintBuilder {
  typedef Constraint Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x0(int64_t x0) {
    fbb_.AddElement<int64_t>(Constraint::VT_X0, x0, 0);
  }
  void add_y0(int64_t y0) {
    fbb_.AddElement<int64_t>(Constraint::VT_Y0, y0, 0);
  }
  void add_x1(int64_t x1) {
    fbb_.AddElement<int64_t>(Constraint::VT_X1, x1, 0);
  }
  void add_y1(int64_t y1) {
    fbb_.AddElement<int64_t>(Constraint::VT_Y1, y1, 0);
  }
  explicit ConstraintBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Constraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Constraint>(end);
    return o;
  }
};

inline flatbuffers::Offset<Constraint> CreateConstraint(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t x0 = 0,
    int64_t y0 = 0,
    int64_t x1 = 0,
    int64_t y1 = 0) {
  ConstraintBuilder builder_(_fbb);
  builder_.add_y1(y1);
  builder_.add_x1(x1);
  builder_.add_y0(y0);
  builder_.add_x0(x0);
  return builder_.Finish();
}

flatbuffers::Offset<Constraint> CreateConstraint(flatbuffers::FlatBufferBuilder &_fbb, const ConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WindowConfigurationDataT : public flatbuffers::NativeTable {
  typedef WindowConfigurationData TableType;
  uint32_t camera_port = 0;
  uint32_t laser_port = 0;
  std::vector<std::unique_ptr<joescan::schema::client::ConstraintT>> constraints{};
};

struct WindowConfigurationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WindowConfigurationDataT NativeTableType;
  typedef WindowConfigurationDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAMERA_PORT = 4,
    VT_LASER_PORT = 6,
    VT_CONSTRAINTS = 8
  };
  uint32_t camera_port() const {
    return GetField<uint32_t>(VT_CAMERA_PORT, 0);
  }
  uint32_t laser_port() const {
    return GetField<uint32_t>(VT_LASER_PORT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<joescan::schema::client::Constraint>> *constraints() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<joescan::schema::client::Constraint>> *>(VT_CONSTRAINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_PORT) &&
           VerifyOffset(verifier, VT_CONSTRAINTS) &&
           verifier.VerifyVector(constraints()) &&
           verifier.VerifyVectorOfTables(constraints()) &&
           verifier.EndTable();
  }
  WindowConfigurationDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WindowConfigurationDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WindowConfigurationData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WindowConfigurationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WindowConfigurationDataBuilder {
  typedef WindowConfigurationData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_camera_port(uint32_t camera_port) {
    fbb_.AddElement<uint32_t>(WindowConfigurationData::VT_CAMERA_PORT, camera_port, 0);
  }
  void add_laser_port(uint32_t laser_port) {
    fbb_.AddElement<uint32_t>(WindowConfigurationData::VT_LASER_PORT, laser_port, 0);
  }
  void add_constraints(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<joescan::schema::client::Constraint>>> constraints) {
    fbb_.AddOffset(WindowConfigurationData::VT_CONSTRAINTS, constraints);
  }
  explicit WindowConfigurationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<WindowConfigurationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WindowConfigurationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<WindowConfigurationData> CreateWindowConfigurationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<joescan::schema::client::Constraint>>> constraints = 0) {
  WindowConfigurationDataBuilder builder_(_fbb);
  builder_.add_constraints(constraints);
  builder_.add_laser_port(laser_port);
  builder_.add_camera_port(camera_port);
  return builder_.Finish();
}

inline flatbuffers::Offset<WindowConfigurationData> CreateWindowConfigurationDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    const std::vector<flatbuffers::Offset<joescan::schema::client::Constraint>> *constraints = nullptr) {
  auto constraints__ = constraints ? _fbb.CreateVector<flatbuffers::Offset<joescan::schema::client::Constraint>>(*constraints) : 0;
  return joescan::schema::client::CreateWindowConfigurationData(
      _fbb,
      camera_port,
      laser_port,
      constraints__);
}

flatbuffers::Offset<WindowConfigurationData> CreateWindowConfigurationData(flatbuffers::FlatBufferBuilder &_fbb, const WindowConfigurationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExclusionMaskDataT : public flatbuffers::NativeTable {
  typedef ExclusionMaskData TableType;
  uint32_t camera_port = 0;
  uint32_t laser_port = 0;
  std::vector<uint8_t> mask{};
};

struct ExclusionMaskData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExclusionMaskDataT NativeTableType;
  typedef ExclusionMaskDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAMERA_PORT = 4,
    VT_LASER_PORT = 6,
    VT_MASK = 8
  };
  uint32_t camera_port() const {
    return GetField<uint32_t>(VT_CAMERA_PORT, 0);
  }
  uint32_t laser_port() const {
    return GetField<uint32_t>(VT_LASER_PORT, 0);
  }
  const flatbuffers::Vector<uint8_t> *mask() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MASK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_PORT) &&
           VerifyOffset(verifier, VT_MASK) &&
           verifier.VerifyVector(mask()) &&
           verifier.EndTable();
  }
  ExclusionMaskDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExclusionMaskDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExclusionMaskData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExclusionMaskDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExclusionMaskDataBuilder {
  typedef ExclusionMaskData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_camera_port(uint32_t camera_port) {
    fbb_.AddElement<uint32_t>(ExclusionMaskData::VT_CAMERA_PORT, camera_port, 0);
  }
  void add_laser_port(uint32_t laser_port) {
    fbb_.AddElement<uint32_t>(ExclusionMaskData::VT_LASER_PORT, laser_port, 0);
  }
  void add_mask(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mask) {
    fbb_.AddOffset(ExclusionMaskData::VT_MASK, mask);
  }
  explicit ExclusionMaskDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExclusionMaskData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExclusionMaskData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExclusionMaskData> CreateExclusionMaskData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mask = 0) {
  ExclusionMaskDataBuilder builder_(_fbb);
  builder_.add_mask(mask);
  builder_.add_laser_port(laser_port);
  builder_.add_camera_port(camera_port);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExclusionMaskData> CreateExclusionMaskDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    const std::vector<uint8_t> *mask = nullptr) {
  auto mask__ = mask ? _fbb.CreateVector<uint8_t>(*mask) : 0;
  return joescan::schema::client::CreateExclusionMaskData(
      _fbb,
      camera_port,
      laser_port,
      mask__);
}

flatbuffers::Offset<ExclusionMaskData> CreateExclusionMaskData(flatbuffers::FlatBufferBuilder &_fbb, const ExclusionMaskDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BrightnessCorrectionDataT : public flatbuffers::NativeTable {
  typedef BrightnessCorrectionData TableType;
  uint32_t camera_port = 0;
  uint32_t laser_port = 0;
  int32_t image_offset = 0;
  std::vector<float> scale_factors{};
};

struct BrightnessCorrectionData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BrightnessCorrectionDataT NativeTableType;
  typedef BrightnessCorrectionDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAMERA_PORT = 4,
    VT_LASER_PORT = 6,
    VT_IMAGE_OFFSET = 8,
    VT_SCALE_FACTORS = 10
  };
  uint32_t camera_port() const {
    return GetField<uint32_t>(VT_CAMERA_PORT, 0);
  }
  uint32_t laser_port() const {
    return GetField<uint32_t>(VT_LASER_PORT, 0);
  }
  int32_t image_offset() const {
    return GetField<int32_t>(VT_IMAGE_OFFSET, 0);
  }
  const flatbuffers::Vector<float> *scale_factors() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE_FACTORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_PORT) &&
           VerifyField<uint32_t>(verifier, VT_LASER_PORT) &&
           VerifyField<int32_t>(verifier, VT_IMAGE_OFFSET) &&
           VerifyOffset(verifier, VT_SCALE_FACTORS) &&
           verifier.VerifyVector(scale_factors()) &&
           verifier.EndTable();
  }
  BrightnessCorrectionDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BrightnessCorrectionDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BrightnessCorrectionData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BrightnessCorrectionDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BrightnessCorrectionDataBuilder {
  typedef BrightnessCorrectionData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_camera_port(uint32_t camera_port) {
    fbb_.AddElement<uint32_t>(BrightnessCorrectionData::VT_CAMERA_PORT, camera_port, 0);
  }
  void add_laser_port(uint32_t laser_port) {
    fbb_.AddElement<uint32_t>(BrightnessCorrectionData::VT_LASER_PORT, laser_port, 0);
  }
  void add_image_offset(int32_t image_offset) {
    fbb_.AddElement<int32_t>(BrightnessCorrectionData::VT_IMAGE_OFFSET, image_offset, 0);
  }
  void add_scale_factors(flatbuffers::Offset<flatbuffers::Vector<float>> scale_factors) {
    fbb_.AddOffset(BrightnessCorrectionData::VT_SCALE_FACTORS, scale_factors);
  }
  explicit BrightnessCorrectionDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BrightnessCorrectionData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BrightnessCorrectionData>(end);
    return o;
  }
};

inline flatbuffers::Offset<BrightnessCorrectionData> CreateBrightnessCorrectionData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    int32_t image_offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale_factors = 0) {
  BrightnessCorrectionDataBuilder builder_(_fbb);
  builder_.add_scale_factors(scale_factors);
  builder_.add_image_offset(image_offset);
  builder_.add_laser_port(laser_port);
  builder_.add_camera_port(camera_port);
  return builder_.Finish();
}

inline flatbuffers::Offset<BrightnessCorrectionData> CreateBrightnessCorrectionDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t camera_port = 0,
    uint32_t laser_port = 0,
    int32_t image_offset = 0,
    const std::vector<float> *scale_factors = nullptr) {
  auto scale_factors__ = scale_factors ? _fbb.CreateVector<float>(*scale_factors) : 0;
  return joescan::schema::client::CreateBrightnessCorrectionData(
      _fbb,
      camera_port,
      laser_port,
      image_offset,
      scale_factors__);
}

flatbuffers::Offset<BrightnessCorrectionData> CreateBrightnessCorrectionData(flatbuffers::FlatBufferBuilder &_fbb, const BrightnessCorrectionDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ScanStartDataT : public flatbuffers::NativeTable {
  typedef ScanStartData TableType;
  uint64_t start_time_ns = 0;
};

struct ScanStartData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScanStartDataT NativeTableType;
  typedef ScanStartDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_TIME_NS = 4
  };
  uint64_t start_time_ns() const {
    return GetField<uint64_t>(VT_START_TIME_NS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_START_TIME_NS) &&
           verifier.EndTable();
  }
  ScanStartDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ScanStartDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ScanStartData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScanStartDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ScanStartDataBuilder {
  typedef ScanStartData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start_time_ns(uint64_t start_time_ns) {
    fbb_.AddElement<uint64_t>(ScanStartData::VT_START_TIME_NS, start_time_ns, 0);
  }
  explicit ScanStartDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScanStartData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScanStartData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScanStartData> CreateScanStartData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t start_time_ns = 0) {
  ScanStartDataBuilder builder_(_fbb);
  builder_.add_start_time_ns(start_time_ns);
  return builder_.Finish();
}

flatbuffers::Offset<ScanStartData> CreateScanStartData(flatbuffers::FlatBufferBuilder &_fbb, const ScanStartDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageClientT : public flatbuffers::NativeTable {
  typedef MessageClient TableType;
  joescan::schema::client::MessageType type = joescan::schema::client::MessageType_NONE;
  joescan::schema::client::MessageDataUnion data{};
};

struct MessageClient FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageClientT NativeTableType;
  typedef MessageClientBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  joescan::schema::client::MessageType type() const {
    return static_cast<joescan::schema::client::MessageType>(GetField<uint16_t>(VT_TYPE, 0));
  }
  joescan::schema::client::MessageData data_type() const {
    return static_cast<joescan::schema::client::MessageData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const joescan::schema::client::ConnectData *data_as_ConnectData() const {
    return data_type() == joescan::schema::client::MessageData_ConnectData ? static_cast<const joescan::schema::client::ConnectData *>(data()) : nullptr;
  }
  const joescan::schema::client::ScanConfigurationData *data_as_ScanConfigurationData() const {
    return data_type() == joescan::schema::client::MessageData_ScanConfigurationData ? static_cast<const joescan::schema::client::ScanConfigurationData *>(data()) : nullptr;
  }
  const joescan::schema::client::WindowConfigurationData *data_as_WindowConfigurationData() const {
    return data_type() == joescan::schema::client::MessageData_WindowConfigurationData ? static_cast<const joescan::schema::client::WindowConfigurationData *>(data()) : nullptr;
  }
  const joescan::schema::client::ImageRequestData *data_as_ImageRequestData() const {
    return data_type() == joescan::schema::client::MessageData_ImageRequestData ? static_cast<const joescan::schema::client::ImageRequestData *>(data()) : nullptr;
  }
  const joescan::schema::client::MappleRequestData *data_as_MappleRequestData() const {
    return data_type() == joescan::schema::client::MessageData_MappleRequestData ? static_cast<const joescan::schema::client::MappleRequestData *>(data()) : nullptr;
  }
  const joescan::schema::client::ProfileRequestData *data_as_ProfileRequestData() const {
    return data_type() == joescan::schema::client::MessageData_ProfileRequestData ? static_cast<const joescan::schema::client::ProfileRequestData *>(data()) : nullptr;
  }
  const joescan::schema::client::ExclusionMaskData *data_as_ExclusionMaskData() const {
    return data_type() == joescan::schema::client::MessageData_ExclusionMaskData ? static_cast<const joescan::schema::client::ExclusionMaskData *>(data()) : nullptr;
  }
  const joescan::schema::client::BrightnessCorrectionData *data_as_BrightnessCorrectionData() const {
    return data_type() == joescan::schema::client::MessageData_BrightnessCorrectionData ? static_cast<const joescan::schema::client::BrightnessCorrectionData *>(data()) : nullptr;
  }
  const joescan::schema::client::ScanStartData *data_as_ScanStartData() const {
    return data_type() == joescan::schema::client::MessageData_ScanStartData ? static_cast<const joescan::schema::client::ScanStartData *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyMessageData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  MessageClientT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageClientT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MessageClient> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageClientT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const joescan::schema::client::ConnectData *MessageClient::data_as<joescan::schema::client::ConnectData>() const {
  return data_as_ConnectData();
}

template<> inline const joescan::schema::client::ScanConfigurationData *MessageClient::data_as<joescan::schema::client::ScanConfigurationData>() const {
  return data_as_ScanConfigurationData();
}

template<> inline const joescan::schema::client::WindowConfigurationData *MessageClient::data_as<joescan::schema::client::WindowConfigurationData>() const {
  return data_as_WindowConfigurationData();
}

template<> inline const joescan::schema::client::ImageRequestData *MessageClient::data_as<joescan::schema::client::ImageRequestData>() const {
  return data_as_ImageRequestData();
}

template<> inline const joescan::schema::client::MappleRequestData *MessageClient::data_as<joescan::schema::client::MappleRequestData>() const {
  return data_as_MappleRequestData();
}

template<> inline const joescan::schema::client::ProfileRequestData *MessageClient::data_as<joescan::schema::client::ProfileRequestData>() const {
  return data_as_ProfileRequestData();
}

template<> inline const joescan::schema::client::ExclusionMaskData *MessageClient::data_as<joescan::schema::client::ExclusionMaskData>() const {
  return data_as_ExclusionMaskData();
}

template<> inline const joescan::schema::client::BrightnessCorrectionData *MessageClient::data_as<joescan::schema::client::BrightnessCorrectionData>() const {
  return data_as_BrightnessCorrectionData();
}

template<> inline const joescan::schema::client::ScanStartData *MessageClient::data_as<joescan::schema::client::ScanStartData>() const {
  return data_as_ScanStartData();
}

struct MessageClientBuilder {
  typedef MessageClient Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(joescan::schema::client::MessageType type) {
    fbb_.AddElement<uint16_t>(MessageClient::VT_TYPE, static_cast<uint16_t>(type), 0);
  }
  void add_data_type(joescan::schema::client::MessageData data_type) {
    fbb_.AddElement<uint8_t>(MessageClient::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(MessageClient::VT_DATA, data);
  }
  explicit MessageClientBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MessageClient> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MessageClient>(end);
    return o;
  }
};

inline flatbuffers::Offset<MessageClient> CreateMessageClient(
    flatbuffers::FlatBufferBuilder &_fbb,
    joescan::schema::client::MessageType type = joescan::schema::client::MessageType_NONE,
    joescan::schema::client::MessageData data_type = joescan::schema::client::MessageData_NONE,
    flatbuffers::Offset<void> data = 0) {
  MessageClientBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

flatbuffers::Offset<MessageClient> CreateMessageClient(flatbuffers::FlatBufferBuilder &_fbb, const MessageClientT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ConnectDataT *ConnectData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConnectDataT>(new ConnectDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConnectData::UnPackTo(ConnectDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scan_head_serial(); _o->scan_head_serial = _e; }
  { auto _e = scan_head_id(); _o->scan_head_id = _e; }
  { auto _e = connection_type(); _o->connection_type = _e; }
}

inline flatbuffers::Offset<ConnectData> ConnectData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConnectData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConnectData> CreateConnectData(flatbuffers::FlatBufferBuilder &_fbb, const ConnectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConnectDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scan_head_serial = _o->scan_head_serial;
  auto _scan_head_id = _o->scan_head_id;
  auto _connection_type = _o->connection_type;
  return joescan::schema::client::CreateConnectData(
      _fbb,
      _scan_head_serial,
      _scan_head_id,
      _connection_type);
}

inline CameraLaserConfigurationT *CameraLaserConfiguration::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CameraLaserConfigurationT>(new CameraLaserConfigurationT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CameraLaserConfiguration::UnPackTo(CameraLaserConfigurationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = camera_port(); _o->camera_port = _e; }
  { auto _e = laser_port(); _o->laser_port = _e; }
  { auto _e = laser_on_time_min_ns(); _o->laser_on_time_min_ns = _e; }
  { auto _e = laser_on_time_def_ns(); _o->laser_on_time_def_ns = _e; }
  { auto _e = laser_on_time_max_ns(); _o->laser_on_time_max_ns = _e; }
  { auto _e = scan_end_offset_ns(); _o->scan_end_offset_ns = _e; }
  { auto _e = camera_orientation(); _o->camera_orientation = _e; }
}

inline flatbuffers::Offset<CameraLaserConfiguration> CameraLaserConfiguration::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CameraLaserConfigurationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCameraLaserConfiguration(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CameraLaserConfiguration> CreateCameraLaserConfiguration(flatbuffers::FlatBufferBuilder &_fbb, const CameraLaserConfigurationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CameraLaserConfigurationT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _camera_port = _o->camera_port;
  auto _laser_port = _o->laser_port;
  auto _laser_on_time_min_ns = _o->laser_on_time_min_ns;
  auto _laser_on_time_def_ns = _o->laser_on_time_def_ns;
  auto _laser_on_time_max_ns = _o->laser_on_time_max_ns;
  auto _scan_end_offset_ns = _o->scan_end_offset_ns;
  auto _camera_orientation = _o->camera_orientation;
  return joescan::schema::client::CreateCameraLaserConfiguration(
      _fbb,
      _camera_port,
      _laser_port,
      _laser_on_time_min_ns,
      _laser_on_time_def_ns,
      _laser_on_time_max_ns,
      _scan_end_offset_ns,
      _camera_orientation);
}

inline ScanConfigurationDataT *ScanConfigurationData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScanConfigurationDataT>(new ScanConfigurationDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScanConfigurationData::UnPackTo(ScanConfigurationDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data_type_mask(); _o->data_type_mask = _e; }
  { auto _e = data_stride(); _o->data_stride = _e; }
  { auto _e = scan_period_ns(); _o->scan_period_ns = _e; }
  { auto _e = laser_detection_threshold(); _o->laser_detection_threshold = _e; }
  { auto _e = saturation_threshold(); _o->saturation_threshold = _e; }
  { auto _e = saturation_percent(); _o->saturation_percent = _e; }
  { auto _e = camera_laser_configurations(); if (_e) { _o->camera_laser_configurations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->camera_laser_configurations[_i] = std::unique_ptr<joescan::schema::client::CameraLaserConfigurationT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<ScanConfigurationData> ScanConfigurationData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScanConfigurationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScanConfigurationData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScanConfigurationData> CreateScanConfigurationData(flatbuffers::FlatBufferBuilder &_fbb, const ScanConfigurationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScanConfigurationDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data_type_mask = _o->data_type_mask;
  auto _data_stride = _o->data_stride;
  auto _scan_period_ns = _o->scan_period_ns;
  auto _laser_detection_threshold = _o->laser_detection_threshold;
  auto _saturation_threshold = _o->saturation_threshold;
  auto _saturation_percent = _o->saturation_percent;
  auto _camera_laser_configurations = _o->camera_laser_configurations.size() ? _fbb.CreateVector<flatbuffers::Offset<joescan::schema::client::CameraLaserConfiguration>> (_o->camera_laser_configurations.size(), [](size_t i, _VectorArgs *__va) { return CreateCameraLaserConfiguration(*__va->__fbb, __va->__o->camera_laser_configurations[i].get(), __va->__rehasher); }, &_va ) : 0;
  return joescan::schema::client::CreateScanConfigurationData(
      _fbb,
      _data_type_mask,
      _data_stride,
      _scan_period_ns,
      _laser_detection_threshold,
      _saturation_threshold,
      _saturation_percent,
      _camera_laser_configurations);
}

inline ImageRequestDataT *ImageRequestData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ImageRequestDataT>(new ImageRequestDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ImageRequestData::UnPackTo(ImageRequestDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = camera_port(); _o->camera_port = _e; }
  { auto _e = laser_port(); _o->laser_port = _e; }
  { auto _e = camera_exposure_ns(); _o->camera_exposure_ns = _e; }
  { auto _e = laser_on_time_ns(); _o->laser_on_time_ns = _e; }
  { auto _e = laser_detection_threshold(); _o->laser_detection_threshold = _e; }
  { auto _e = saturation_threshold(); _o->saturation_threshold = _e; }
  { auto _e = image_data_type(); _o->image_data_type = _e; }
}

inline flatbuffers::Offset<ImageRequestData> ImageRequestData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ImageRequestDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateImageRequestData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ImageRequestData> CreateImageRequestData(flatbuffers::FlatBufferBuilder &_fbb, const ImageRequestDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ImageRequestDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _camera_port = _o->camera_port;
  auto _laser_port = _o->laser_port;
  auto _camera_exposure_ns = _o->camera_exposure_ns;
  auto _laser_on_time_ns = _o->laser_on_time_ns;
  auto _laser_detection_threshold = _o->laser_detection_threshold;
  auto _saturation_threshold = _o->saturation_threshold;
  auto _image_data_type = _o->image_data_type;
  return joescan::schema::client::CreateImageRequestData(
      _fbb,
      _camera_port,
      _laser_port,
      _camera_exposure_ns,
      _laser_on_time_ns,
      _laser_detection_threshold,
      _saturation_threshold,
      _image_data_type);
}

inline ProfileRequestDataT *ProfileRequestData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProfileRequestDataT>(new ProfileRequestDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProfileRequestData::UnPackTo(ProfileRequestDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = camera_port(); _o->camera_port = _e; }
  { auto _e = laser_port(); _o->laser_port = _e; }
  { auto _e = camera_exposure_ns(); _o->camera_exposure_ns = _e; }
  { auto _e = laser_on_time_ns(); _o->laser_on_time_ns = _e; }
  { auto _e = laser_detection_threshold(); _o->laser_detection_threshold = _e; }
  { auto _e = saturation_threshold(); _o->saturation_threshold = _e; }
  { auto _e = camera_orientation(); _o->camera_orientation = _e; }
}

inline flatbuffers::Offset<ProfileRequestData> ProfileRequestData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProfileRequestDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProfileRequestData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProfileRequestData> CreateProfileRequestData(flatbuffers::FlatBufferBuilder &_fbb, const ProfileRequestDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProfileRequestDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _camera_port = _o->camera_port;
  auto _laser_port = _o->laser_port;
  auto _camera_exposure_ns = _o->camera_exposure_ns;
  auto _laser_on_time_ns = _o->laser_on_time_ns;
  auto _laser_detection_threshold = _o->laser_detection_threshold;
  auto _saturation_threshold = _o->saturation_threshold;
  auto _camera_orientation = _o->camera_orientation;
  return joescan::schema::client::CreateProfileRequestData(
      _fbb,
      _camera_port,
      _laser_port,
      _camera_exposure_ns,
      _laser_on_time_ns,
      _laser_detection_threshold,
      _saturation_threshold,
      _camera_orientation);
}

inline MappleRequestDataT *MappleRequestData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MappleRequestDataT>(new MappleRequestDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MappleRequestData::UnPackTo(MappleRequestDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = camera_port(); _o->camera_port = _e; }
  { auto _e = laser_port(); _o->laser_port = _e; }
}

inline flatbuffers::Offset<MappleRequestData> MappleRequestData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MappleRequestDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMappleRequestData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MappleRequestData> CreateMappleRequestData(flatbuffers::FlatBufferBuilder &_fbb, const MappleRequestDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MappleRequestDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _camera_port = _o->camera_port;
  auto _laser_port = _o->laser_port;
  return joescan::schema::client::CreateMappleRequestData(
      _fbb,
      _camera_port,
      _laser_port);
}

inline ConstraintT *Constraint::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConstraintT>(new ConstraintT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Constraint::UnPackTo(ConstraintT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = x0(); _o->x0 = _e; }
  { auto _e = y0(); _o->y0 = _e; }
  { auto _e = x1(); _o->x1 = _e; }
  { auto _e = y1(); _o->y1 = _e; }
}

inline flatbuffers::Offset<Constraint> Constraint::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConstraintT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConstraint(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Constraint> CreateConstraint(flatbuffers::FlatBufferBuilder &_fbb, const ConstraintT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConstraintT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _x0 = _o->x0;
  auto _y0 = _o->y0;
  auto _x1 = _o->x1;
  auto _y1 = _o->y1;
  return joescan::schema::client::CreateConstraint(
      _fbb,
      _x0,
      _y0,
      _x1,
      _y1);
}

inline WindowConfigurationDataT *WindowConfigurationData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WindowConfigurationDataT>(new WindowConfigurationDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WindowConfigurationData::UnPackTo(WindowConfigurationDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = camera_port(); _o->camera_port = _e; }
  { auto _e = laser_port(); _o->laser_port = _e; }
  { auto _e = constraints(); if (_e) { _o->constraints.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->constraints[_i] = std::unique_ptr<joescan::schema::client::ConstraintT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<WindowConfigurationData> WindowConfigurationData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WindowConfigurationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWindowConfigurationData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WindowConfigurationData> CreateWindowConfigurationData(flatbuffers::FlatBufferBuilder &_fbb, const WindowConfigurationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WindowConfigurationDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _camera_port = _o->camera_port;
  auto _laser_port = _o->laser_port;
  auto _constraints = _o->constraints.size() ? _fbb.CreateVector<flatbuffers::Offset<joescan::schema::client::Constraint>> (_o->constraints.size(), [](size_t i, _VectorArgs *__va) { return CreateConstraint(*__va->__fbb, __va->__o->constraints[i].get(), __va->__rehasher); }, &_va ) : 0;
  return joescan::schema::client::CreateWindowConfigurationData(
      _fbb,
      _camera_port,
      _laser_port,
      _constraints);
}

inline ExclusionMaskDataT *ExclusionMaskData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExclusionMaskDataT>(new ExclusionMaskDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExclusionMaskData::UnPackTo(ExclusionMaskDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = camera_port(); _o->camera_port = _e; }
  { auto _e = laser_port(); _o->laser_port = _e; }
  { auto _e = mask(); if (_e) { _o->mask.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->mask.begin()); } }
}

inline flatbuffers::Offset<ExclusionMaskData> ExclusionMaskData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExclusionMaskDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExclusionMaskData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExclusionMaskData> CreateExclusionMaskData(flatbuffers::FlatBufferBuilder &_fbb, const ExclusionMaskDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExclusionMaskDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _camera_port = _o->camera_port;
  auto _laser_port = _o->laser_port;
  auto _mask = _o->mask.size() ? _fbb.CreateVector(_o->mask) : 0;
  return joescan::schema::client::CreateExclusionMaskData(
      _fbb,
      _camera_port,
      _laser_port,
      _mask);
}

inline BrightnessCorrectionDataT *BrightnessCorrectionData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BrightnessCorrectionDataT>(new BrightnessCorrectionDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BrightnessCorrectionData::UnPackTo(BrightnessCorrectionDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = camera_port(); _o->camera_port = _e; }
  { auto _e = laser_port(); _o->laser_port = _e; }
  { auto _e = image_offset(); _o->image_offset = _e; }
  { auto _e = scale_factors(); if (_e) { _o->scale_factors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scale_factors[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<BrightnessCorrectionData> BrightnessCorrectionData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BrightnessCorrectionDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBrightnessCorrectionData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BrightnessCorrectionData> CreateBrightnessCorrectionData(flatbuffers::FlatBufferBuilder &_fbb, const BrightnessCorrectionDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BrightnessCorrectionDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _camera_port = _o->camera_port;
  auto _laser_port = _o->laser_port;
  auto _image_offset = _o->image_offset;
  auto _scale_factors = _o->scale_factors.size() ? _fbb.CreateVector(_o->scale_factors) : 0;
  return joescan::schema::client::CreateBrightnessCorrectionData(
      _fbb,
      _camera_port,
      _laser_port,
      _image_offset,
      _scale_factors);
}

inline ScanStartDataT *ScanStartData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ScanStartDataT>(new ScanStartDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ScanStartData::UnPackTo(ScanStartDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = start_time_ns(); _o->start_time_ns = _e; }
}

inline flatbuffers::Offset<ScanStartData> ScanStartData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ScanStartDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateScanStartData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ScanStartData> CreateScanStartData(flatbuffers::FlatBufferBuilder &_fbb, const ScanStartDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ScanStartDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _start_time_ns = _o->start_time_ns;
  return joescan::schema::client::CreateScanStartData(
      _fbb,
      _start_time_ns);
}

inline MessageClientT *MessageClient::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MessageClientT>(new MessageClientT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MessageClient::UnPackTo(MessageClientT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = joescan::schema::client::MessageDataUnion::UnPack(_e, data_type(), _resolver); }
}

inline flatbuffers::Offset<MessageClient> MessageClient::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageClientT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessageClient(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MessageClient> CreateMessageClient(flatbuffers::FlatBufferBuilder &_fbb, const MessageClientT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageClientT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return joescan::schema::client::CreateMessageClient(
      _fbb,
      _type,
      _data_type,
      _data);
}

inline bool VerifyMessageData(flatbuffers::Verifier &verifier, const void *obj, MessageData type) {
  switch (type) {
    case MessageData_NONE: {
      return true;
    }
    case MessageData_ConnectData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ConnectData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_ScanConfigurationData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ScanConfigurationData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_WindowConfigurationData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::WindowConfigurationData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_ImageRequestData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ImageRequestData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_MappleRequestData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::MappleRequestData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_ProfileRequestData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ProfileRequestData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_ExclusionMaskData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ExclusionMaskData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_BrightnessCorrectionData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::BrightnessCorrectionData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageData_ScanStartData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ScanStartData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyMessageDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageData(
        verifier,  values->Get(i), types->GetEnum<MessageData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *MessageDataUnion::UnPack(const void *obj, MessageData type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case MessageData_ConnectData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ConnectData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_ScanConfigurationData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ScanConfigurationData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_WindowConfigurationData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::WindowConfigurationData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_ImageRequestData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ImageRequestData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_MappleRequestData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::MappleRequestData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_ProfileRequestData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ProfileRequestData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_ExclusionMaskData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ExclusionMaskData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_BrightnessCorrectionData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::BrightnessCorrectionData *>(obj);
      return ptr->UnPack(resolver);
    }
    case MessageData_ScanStartData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ScanStartData *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> MessageDataUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case MessageData_ConnectData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ConnectDataT *>(value);
      return CreateConnectData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_ScanConfigurationData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ScanConfigurationDataT *>(value);
      return CreateScanConfigurationData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_WindowConfigurationData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::WindowConfigurationDataT *>(value);
      return CreateWindowConfigurationData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_ImageRequestData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ImageRequestDataT *>(value);
      return CreateImageRequestData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_MappleRequestData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::MappleRequestDataT *>(value);
      return CreateMappleRequestData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_ProfileRequestData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ProfileRequestDataT *>(value);
      return CreateProfileRequestData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_ExclusionMaskData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ExclusionMaskDataT *>(value);
      return CreateExclusionMaskData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_BrightnessCorrectionData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::BrightnessCorrectionDataT *>(value);
      return CreateBrightnessCorrectionData(_fbb, ptr, _rehasher).Union();
    }
    case MessageData_ScanStartData: {
      auto ptr = reinterpret_cast<const joescan::schema::client::ScanStartDataT *>(value);
      return CreateScanStartData(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline MessageDataUnion::MessageDataUnion(const MessageDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case MessageData_ConnectData: {
      value = new joescan::schema::client::ConnectDataT(*reinterpret_cast<joescan::schema::client::ConnectDataT *>(u.value));
      break;
    }
    case MessageData_ScanConfigurationData: {
      FLATBUFFERS_ASSERT(false);  // joescan::schema::client::ScanConfigurationDataT not copyable.
      break;
    }
    case MessageData_WindowConfigurationData: {
      FLATBUFFERS_ASSERT(false);  // joescan::schema::client::WindowConfigurationDataT not copyable.
      break;
    }
    case MessageData_ImageRequestData: {
      value = new joescan::schema::client::ImageRequestDataT(*reinterpret_cast<joescan::schema::client::ImageRequestDataT *>(u.value));
      break;
    }
    case MessageData_MappleRequestData: {
      value = new joescan::schema::client::MappleRequestDataT(*reinterpret_cast<joescan::schema::client::MappleRequestDataT *>(u.value));
      break;
    }
    case MessageData_ProfileRequestData: {
      value = new joescan::schema::client::ProfileRequestDataT(*reinterpret_cast<joescan::schema::client::ProfileRequestDataT *>(u.value));
      break;
    }
    case MessageData_ExclusionMaskData: {
      value = new joescan::schema::client::ExclusionMaskDataT(*reinterpret_cast<joescan::schema::client::ExclusionMaskDataT *>(u.value));
      break;
    }
    case MessageData_BrightnessCorrectionData: {
      value = new joescan::schema::client::BrightnessCorrectionDataT(*reinterpret_cast<joescan::schema::client::BrightnessCorrectionDataT *>(u.value));
      break;
    }
    case MessageData_ScanStartData: {
      value = new joescan::schema::client::ScanStartDataT(*reinterpret_cast<joescan::schema::client::ScanStartDataT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void MessageDataUnion::Reset() {
  switch (type) {
    case MessageData_ConnectData: {
      auto ptr = reinterpret_cast<joescan::schema::client::ConnectDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_ScanConfigurationData: {
      auto ptr = reinterpret_cast<joescan::schema::client::ScanConfigurationDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_WindowConfigurationData: {
      auto ptr = reinterpret_cast<joescan::schema::client::WindowConfigurationDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_ImageRequestData: {
      auto ptr = reinterpret_cast<joescan::schema::client::ImageRequestDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_MappleRequestData: {
      auto ptr = reinterpret_cast<joescan::schema::client::MappleRequestDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_ProfileRequestData: {
      auto ptr = reinterpret_cast<joescan::schema::client::ProfileRequestDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_ExclusionMaskData: {
      auto ptr = reinterpret_cast<joescan::schema::client::ExclusionMaskDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_BrightnessCorrectionData: {
      auto ptr = reinterpret_cast<joescan::schema::client::BrightnessCorrectionDataT *>(value);
      delete ptr;
      break;
    }
    case MessageData_ScanStartData: {
      auto ptr = reinterpret_cast<joescan::schema::client::ScanStartDataT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = MessageData_NONE;
}

inline const joescan::schema::client::MessageClient *GetMessageClient(const void *buf) {
  return flatbuffers::GetRoot<joescan::schema::client::MessageClient>(buf);
}

inline const joescan::schema::client::MessageClient *GetSizePrefixedMessageClient(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<joescan::schema::client::MessageClient>(buf);
}

inline bool VerifyMessageClientBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<joescan::schema::client::MessageClient>(nullptr);
}

inline bool VerifySizePrefixedMessageClientBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<joescan::schema::client::MessageClient>(nullptr);
}

inline void FinishMessageClientBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<joescan::schema::client::MessageClient> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageClientBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<joescan::schema::client::MessageClient> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<joescan::schema::client::MessageClientT> UnPackMessageClient(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<joescan::schema::client::MessageClientT>(GetMessageClient(buf)->UnPack(res));
}

inline std::unique_ptr<joescan::schema::client::MessageClientT> UnPackSizePrefixedMessageClient(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<joescan::schema::client::MessageClientT>(GetSizePrefixedMessageClient(buf)->UnPack(res));
}

}  // namespace client
}  // namespace schema
}  // namespace joescan

#endif  // FLATBUFFERS_GENERATED_MESSAGECLIENT_JOESCAN_SCHEMA_CLIENT_H_
